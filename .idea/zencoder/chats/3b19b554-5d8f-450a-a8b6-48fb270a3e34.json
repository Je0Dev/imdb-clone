{
    "checksum": "53052974e0b7ba180d4a488f622cc1c7a4dc81be3aad6e4bc600707d805a503f",
    "data": {
    "id": "3b19b554-5d8f-450a-a8b6-48fb270a3e34",
    "createdAt": 1754580707102,
    "updatedAt": 1754580711266,
    "title": "/fix actor.contains(searchActor) Cannot resolve...",
    "messages": [
        {
            "id": "09bd3ee0-bbb9-403b-ab5e-0814dc99d97e",
            "role": "user",
            "content": [
                {
                    "type": "command",
                    "commandName": "fix"
                },
                {
                    "type": "codeSnippet",
                    "text": "actor.contains(searchActor)",
                    "language": "java"
                },
                {
                    "type": "text",
                    "text": "Cannot resolve method 'contains' in 'Object'"
                }
            ],
            "context": {
                "currentFile": {
                    "path": "C:\\Users\\mas_b\\IdeaProjects\\imdb_clone\\src\\main\\java\\com\\papel\\imdb_clone\\data\\DataManager.java",
                    "fsPath": "C:/Users/mas_b/IdeaProjects/imdb_clone/src/main/java/com/papel/imdb_clone/data/DataManager.java",
                    "content": "package com.papel.imdb_clone.data;\n\nimport com.papel.imdb_clone.enums.Genre;\nimport com.papel.imdb_clone.exceptions.DuplicateContentException;\nimport com.papel.imdb_clone.exceptions.DuplicateUsernameException;\nimport com.papel.imdb_clone.exceptions.FileParsingException;\nimport com.papel.imdb_clone.model.*;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.time.LocalDate;\nimport java.time.LocalDateTime;\nimport java.time.format.DateTimeFormatter;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.stream.Collectors;\n\npublic class DataManager {\n    private final List<User> users;\n    private final List<Actor> actors;\n    private final List<Director> directors;\n    private final List<Movie> movies;\n    private final List<Series> series;\n    private final List<ForumPost> forumPosts;\n\n    private int nextUserId = 1;\n    private int nextActorId = 1;\n    private int nextDirectorId = 1;\n    private int nextMovieId = 1;\n    private int nextSeriesId = 1;\n    private int nextSeasonId = 1;\n    private int nextEpisodeId = 1;\n    private int nextForumPostId = 1;\n    private final int nextForumPostIdSanitized = 1; // For tracking the next available sanitized ID\n    private final Object forumPostLock = new Object();\n    private final Object movieLock = new Object();\n    private final Object seriesLock = new Object();\n\n    private static final Logger logger = LoggerFactory.getLogger(DataManager.class.getName());\n\n    // We don't need separate allMovies and allSeries fields since we already have movies and series lists\n\n    /**\n     * Initializes a new instance of the DataManager class.\n     * This constructor sets up empty lists for users, actors, directors, movies, series, and forum posts.\n     */\n    public DataManager() {\n        this.users = new ArrayList<>();\n        this.actors = new ArrayList<>();\n\n        this.directors = new ArrayList<>();\n        this.movies = new ArrayList<>();\n        this.series = new ArrayList<>();\n        this.forumPosts = new ArrayList<>();\n    }\n\n\n    public void loadAllData() {\n        loadUsers(\"users.txt\");\n        loadActors(\"actors.txt\");\n        loadDirectors(\"directors.txt\");\n        loadMovies(\"movies.txt\");\n        loadSeries(\"series.txt\");\n        loadAwardsAndBoxOffice(\"awards_boxoffice.txt\");\n        loadForumPosts(\"forum_posts.txt\");\n    }\n\n    public void loadUsers(String filename) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = parseCSVLine(line);\n                if (parts.length >= 6) {\n\n                    // Format: firstName,middleName/nickname,lastName,gender,nationality,username\n                    String firstName = parts[0];\n                    String middleName = parts[1].replaceAll(\"\\\"\", \"\"); // Remove quotes\n                    String lastName = parts[2];\n                    char gender = parts[3].charAt(0);\n                    String nationality = parts[4];\n                    String username = parts[5];\n\n                    // Combine names appropriately\n                    String fullFirstName = middleName.isEmpty() ? firstName : firstName + \" \" + middleName;\n                    User user = new User(fullFirstName, lastName, username, gender, nationality);\n                    user.setId(nextUserId++);\n                    users.add(user);\n                } else if (parts.length >= 5) {\n                    // Standard format: firstName,lastName,username,gender,nationality\n                    User user = new User(parts[0], parts[1], parts[2], parts[3].charAt(0), parts[4]);\n                    user.setId(nextUserId++);\n                    users.add(user);\n                }\n            }\n        } catch (IOException e) {\n            throw new FileParsingException(\"Error loading users: \" + e.getMessage());\n        }\n    }\n\n    public void loadActors(String filename) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = parseCSVLine(line);\n                if (parts.length >= 6) {\n                    // Handle the case where middle name/nickname is quoted\n                    // Format: firstName,middleName/nickname,lastName,birthDate,gender,nationality\n                    String firstName = parts[0];\n                    String middleName = parts[1].replaceAll(\"\\\"\", \"\"); // Remove quotes\n                    String lastName = parts[2];\n                    LocalDate birthDate = LocalDate.parse(parts[3], DateTimeFormatter.ISO_LOCAL_DATE);\n                    char gender = parts[4].charAt(0);\n                    String nationality = parts[5];\n\n                    // Combine names appropriately\n                    String fullFirstName = middleName.isEmpty() ? firstName : firstName + \" \" + middleName;\n                    Actor actor = new Actor(fullFirstName, lastName, birthDate, gender, nationality);\n                    actor.setId(nextActorId++);\n                    actors.add(actor);\n                } else if (parts.length >= 5) {\n                    // Standard format: firstName,lastName,birthDate,gender,nationality\n                    LocalDate birthDate = LocalDate.parse(parts[2], DateTimeFormatter.ISO_LOCAL_DATE);\n                    Actor actor = new Actor(parts[0], parts[1], birthDate, parts[3].charAt(0), parts[4]);\n                    actor.setId(nextActorId++);\n                    actors.add(actor);\n                }\n            }\n        } catch (IOException e) {\n            throw new FileParsingException(\"Error loading actors: \" + e.getMessage());\n        }\n    }\n\n    public void loadDirectors(String filename) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = parseCSVLine(line);\n                if (parts.length >= 5) {\n                    // Handle the case where middle name/nickname is quoted\n                    // Format: firstName,middleName/nickname,lastName,birthDate,gender\n                    String firstName = parts[0];\n                    String middleName = parts[1].replaceAll(\"\\\"\", \"\"); // Remove quotes\n                    String lastName = parts[2];\n                    LocalDate birthDate = LocalDate.parse(parts[3], DateTimeFormatter.ISO_LOCAL_DATE);\n                    char gender = parts[4].charAt(0);\n\n                    // Combine names appropriately\n                    String fullFirstName = middleName.isEmpty() ? firstName : firstName + \" \" + middleName;\n                    Director director = new Director(fullFirstName, lastName, birthDate, gender);\n                    director.setId(nextDirectorId++);\n                    directors.add(director);\n                } else if (parts.length >= 4) {\n                    // Standard format: firstName,lastName,birthDate,gender\n                    LocalDate birthDate = LocalDate.parse(parts[2], DateTimeFormatter.ISO_LOCAL_DATE);\n                    Director director = new Director(parts[0], parts[1], birthDate, parts[3].charAt(0));\n                    director.setId(nextDirectorId++);\n                    directors.add(director);\n                }\n            }\n        } catch (IOException e) {\n            throw new FileParsingException(\"Error loading directors: \" + e.getMessage());\n        }\n    }\n\n    public void loadMovies(String filename) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = parseCSVLine(line);\n                if (parts.length >= 6) {\n                    String title = parts[0];\n                    int year = Integer.parseInt(parts[1]);\n                    Genre genre = Genre.valueOf(parts[2].toUpperCase().replace(\" \", \"_\"));\n                    int duration = Integer.parseInt(parts[3]);\n                    Director director = findDirectorByName(parts[4]);\n                    double imdbRating = Double.parseDouble(parts[5]);\n\n                    List<Actor> movieActors = new ArrayList<>();\n                    if (parts.length > 6) {\n                        String[] actorNames = parts[6].split(\";\");\n                        for (String actorName : actorNames) {\n                            Actor actor = findActorByName(actorName.trim());\n                            if (actor != null) {\n                                movieActors.add(actor);\n                            }\n                        }\n                    }\n\n                    // Handle case where director might be null\n                    Movie movie;\n                    if (director != null) {\n                        movie = new Movie(title, year, director, null, duration, movieActors, imdbRating);\n                    } else {\n                        // Create a movie with genre and director name from the file when director object is not found\n                        movie = new Movie(title, year, genre.name(), parts[4], new HashMap<>(), imdbRating);\n                        movie.setActors(movieActors);\n                    }\n                    movie.setId(nextMovieId++);\n                    movies.add(movie);\n                }\n            }\n        } catch (IOException e) {\n            throw new FileParsingException(\"Error loading movies: \" + e.getMessage());\n        }\n    }\n\n    public void loadSeries(String filename) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                String[] parts = parseCSVLine(line);\n                if (parts.length >= 2) {\n                    String title = parts[0];\n                    // Split the genre string on pipe and take the first part\n                    String genreStr = parts[1].split(\"\\\\|\")[0].trim();\n                    Genre genre = Genre.valueOf(genreStr.toUpperCase().replace(\" \", \"_\"));\n\n                    Series series = new Series(title);\n                    series.setGenre(genre);  // Set the genre from the file\n                    series.setId(nextSeriesId++);\n                    this.series.add(series);\n                }\n            }\n        } catch (IOException e) {\n            throw new FileParsingException(\"Error loading series: \" + e.getMessage());\n        }\n    }\n\n    public void loadAwardsAndBoxOffice(String filename) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                // Skip comments and empty lines\n                if (line.trim().isEmpty() || line.startsWith(\"#\")) {\n                    continue;\n                }\n\n                String[] parts = line.split(\"\\\\|\");\n                if (parts.length >= 4) {\n                    String type = parts[0].trim();\n                    String title = parts[1].trim();\n                    String boxOffice = parts[2].trim();\n                    String awardsStr = parts[3].trim();\n\n                    // Parse awards\n                    List<String> awards = new ArrayList<>();\n                    if (!awardsStr.isEmpty()) {\n                        String[] awardArray = awardsStr.split(\";\");\n                        for (String award : awardArray) {\n                            awards.add(award.trim());\n                        }\n                    }\n\n                    // Apply to movies or series\n                    if (\"MOVIE\".equals(type)) {\n                        Movie movie = findMovieByTitle(title);\n                        if (movie != null) {\n                            movie.setBoxOffice(boxOffice);\n                            movie.setAwards(awards);\n                        }\n                    } else if (\"SERIES\".equals(type)) {\n                        Series series = findSeriesByTitle(title);\n                        if (series != null) {\n                            series.setBoxOffice(boxOffice);\n                            series.setAwards(awards);\n                        }\n                    }\n                }\n            }\n        } catch (IOException e) {\n            throw new FileParsingException(\"Error loading awards and box office data: \" + e.getMessage());\n        }\n    }\n\n    public void loadForumPosts(String filename) {\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                // Skip empty lines\n                if (line.trim().isEmpty()) {\n                    continue;\n                }\n\n                String[] parts = parseCSVLine(line);\n                if (parts.length >= 8) {\n                    // Format: id,userId,title,content,createdAt,updatedAt,upvotes,downvotes\n                    int id = Integer.parseInt(parts[0]);\n                    int userId = Integer.parseInt(parts[1]);\n                    String title = parts[2];\n                    String content = parts[3];\n                    LocalDateTime createdAt = LocalDateTime.parse(parts[4]);\n                    LocalDateTime updatedAt = LocalDateTime.parse(parts[5]);\n                    int upvotes = Integer.parseInt(parts[6]);\n                    int downvotes = Integer.parseInt(parts[7]);\n\n                    ForumPost post = new ForumPost(userId, title, content);\n                    post.setId(id); // Use the standard ID setter\n                    post.setCreatedAt(createdAt);\n                    post.setUpdatedAt(updatedAt);\n                    post.setUpvotes(upvotes);\n                    post.setDownvotes(downvotes);\n\n                    // Update the next ID counter to avoid conflicts\n                    if (id >= nextForumPostId) {\n                        nextForumPostId = id + 1;\n                    }\n\n                    forumPosts.add(post);\n                }\n            }\n        } catch (IOException e) {\n            throw new FileParsingException(\"Error loading forum posts: \" + e.getMessage());\n        }\n    }\n\n    public void saveForumPosts(String filename) {\n        try (java.io.PrintWriter writer = new java.io.PrintWriter(\"src/main/resources/data/\" + filename)) {\n            synchronized (forumPostLock) {\n                for (ForumPost post : forumPosts) {\n                    writer.println(String.format(\"%d,%d,\\\"%s\\\",\\\"%s\\\",%s,%s,%d,%d\",\n                            post.getId(),\n                            post.getUserId(),\n                            escapeCsv(post.getTitle()),\n                            escapeCsv(post.getContent()),\n                            post.getCreatedAt(),\n                            post.getUpdatedAt(),\n                            post.getUpvotes(),\n                            post.getDownvotes()));\n                }\n            }\n            logger.info(\"Successfully saved {} forum posts to {}\", forumPosts.size(), filename);\n        } catch (IOException e) {\n            logger.error(\"Error saving forum posts to {}: {}\", filename, e.getMessage(), e);\n            throw new FileParsingException(\"Error saving forum posts: \" + e.getMessage());\n        }\n    }\n\n    private String escapeCsv(String input) {\n        if (input == null) {\n            return \"\";\n        }\n        return input.replace(\"\\\"\", \"\\\"\\\"\");\n    }\n\n    public void addUser(User user) {\n        if (findUserByUsername(user.getUsername()) != null) {\n            throw new DuplicateUsernameException(\"Username already exists: \" + user.getUsername());\n        }\n        user.setId(nextUserId++);\n        users.add(user);\n    }\n\n    public void addActor(Actor actor) {\n        actor.setId(nextActorId++);\n        actors.add(actor);\n    }\n\n    public void addDirector(Director director) {\n        director.setId(nextDirectorId++);\n        directors.add(director);\n    }\n\n    public void addMovie(Movie movie) {\n        if (findMovieByTitle(movie.getTitle()) != null) {\n            throw new DuplicateContentException(\"Movie already exists: \" + movie.getTitle());\n        }\n        movie.setId(nextMovieId++);\n        movies.add(movie);\n    }\n\n    public void addSeries(Series series) {\n        if (findSeriesByTitle(series.getTitle()) != null) {\n            throw new DuplicateContentException(\"Series already exists: \" + series.getTitle());\n        }\n        series.setId(nextSeriesId++);\n        this.series.add(series);\n    }\n\n    public void removeMovie(Movie movie) {\n        if (movie == null) {\n            throw new IllegalArgumentException(\"Movie cannot be null\");\n        }\n        boolean removed = movies.remove(movie);\n        if (!removed) {\n            throw new IllegalArgumentException(\"Movie not found in collection: \" + movie.getTitle());\n        }\n    }\n\n    public void removeSeries(Series series) {\n        if (series == null) {\n            throw new IllegalArgumentException(\"Series cannot be null\");\n        }\n        boolean removed = this.series.remove(series);\n        if (!removed) {\n            throw new IllegalArgumentException(\"Series not found in collection: \" + series.getTitle());\n        }\n    }\n\n    public User findUserByUsername(String username) {\n        return users.stream()\n                .filter(user -> user.getUsername().equals(username))\n                .findFirst()\n                .orElse(null);\n    }\n\n    public User findUserById(int id) {\n        return users.stream()\n                .filter(user -> user.getId() == id)\n                .findFirst()\n                .orElse(null);\n    }\n\n    public Actor findActorByName(String name) {\n        return actors.stream()\n                .filter(actor -> actor.getFullName().equals(name))\n                .findFirst()\n                .orElse(null);\n    }\n\n    public Director findDirectorByName(String name) {\n        return directors.stream()\n                .filter(director -> director.getFullName().equals(name))\n                .findFirst()\n                .orElse(null);\n    }\n\n    public Movie findMovieByTitle(String title) {\n        return movies.stream()\n                .filter(movie -> movie.getTitle().equals(title))\n                .findFirst()\n                .orElse(null);\n    }\n\n    public Series findSeriesByTitle(String title) {\n        return series.stream()\n                .filter(series -> series.getTitle().equals(title))\n                .findFirst()\n                .orElse(null);\n    }\n\n    /**\n     * Searches for content matching the given criteria\n     *\n     * @param criteria The search criteria to match against\n     * @return List of matching content, empty list if no matches or error occurs\n     */\n    public List<Content> searchContent(SearchCriteria criteria) {\n        try {\n            if (criteria == null) {\n                logger.warn(\"Search criteria is null\");\n                return new ArrayList<>();\n            }\n\n            logger.debug(\"Starting search with criteria: {}\", criteria);\n            List<Content> result = new ArrayList<>();\n\n            // Log total counts before filtering\n            logger.debug(\"Total movies: {}, Total series: {}\",\n                    movies != null ? movies.size() : 0,\n                    series != null ? series.size() : 0);\n\n            // Search movies\n            if (movies != null) {\n                try {\n                    List<Content> matchedMovies = movies.stream()\n                            .filter(Objects::nonNull)\n                            .filter(movie -> matchesCriteria(movie, criteria))\n                            .collect(Collectors.toList());\n                    result.addAll(matchedMovies);\n                    logger.debug(\"Found {} matching movies\", matchedMovies.size());\n                } catch (Exception e) {\n                    logger.error(\"Error searching movies: {}\", e.getMessage(), e);\n                }\n            }\n\n            // Search series\n            if (series != null) {\n                try {\n                    List<Content> matchedSeries = series.stream()\n                            .filter(Objects::nonNull)\n                            .filter(series -> matchesCriteria(series, criteria))\n                            .collect(Collectors.toList());\n                    result.addAll(matchedSeries);\n                    logger.debug(\"Found {} matching series\", matchedSeries.size());\n                } catch (Exception e) {\n                    logger.error(\"Error searching series: {}\", e.getMessage(), e);\n                }\n            }\n\n            // Apply sorting if we have results\n            if (!result.isEmpty()) {\n                try {\n                    sortContent(result, criteria);\n                } catch (Exception e) {\n                    logger.error(\"Error sorting results: {}\", e.getMessage(), e);\n                    // Continue with unsorted results rather than failing\n                }\n            } else {\n                logger.debug(\"No content matched the search criteria\");\n            }\n\n            return result;\n        } catch (Exception e) {\n            logger.error(\"Unexpected error in searchContent: {}\", e.getMessage(), e);\n            return new ArrayList<>();\n        }\n    }\n\n    /**\n     * Sorts content based on the specified criteria\n     *\n     * @param content  The content to sort\n     * @param criteria The sort criteria\n     */\n    private void sortContent(List<Content> content, SearchCriteria criteria) {\n        if (content == null || content.isEmpty() || criteria == null) {\n            logger.debug(\"No content to sort or invalid criteria\");\n            return;\n        }\n\n        String sortBy = criteria.getSortBy() != null ? criteria.getSortBy().toLowerCase() : \"title\";\n        logger.debug(\"Sorting {} items by: {} {}\",\n                content.size(),\n                sortBy,\n                criteria.isSortDescending() ? \"descending\" : \"ascending\");\n\n        try {\n            switch (sortBy) {\n                case \"title\":\n                    content.sort((a, b) -> {\n                        if (a == null || b == null) return 0;\n                        String titleA = a.getTitle() != null ? a.getTitle() : \"\";\n                        String titleB = b.getTitle() != null ? b.getTitle() : \"\";\n                        int result = titleA.compareToIgnoreCase(titleB);\n                        return criteria.isSortDescending() ? -result : result;\n                    });\n                    break;\n\n                case \"year\":\n                    content.sort((a, b) -> {\n                        if (a == null || b == null) return 0;\n                        int yearA = (a.getYear() != null) ? a.getYear().getYear() + 1900 : 0;\n                        int yearB = (b.getYear() != null) ? b.getYear().getYear() + 1900 : 0;\n                        int result = Integer.compare(yearA, yearB);\n                        return criteria.isSortDescending() ? -result : result;\n                    });\n                    break;\n\n                case \"rating\":\n                    content.sort((a, b) -> {\n                        if (a == null || b == null) return 0;\n                        double ratingA = 0;\n                        double ratingB = 0;\n                        try {\n                            ratingA = (a instanceof Movie) ?\n                                    a.getImdbRating() :\n                                    a.calculateAverageUserRating();\n                            ratingB = (b instanceof Movie) ?\n                                    b.getImdbRating() :\n                                    b.calculateAverageUserRating();\n                        } catch (Exception e) {\n                            logger.warn(\"Error calculating ratings: {}\", e.getMessage());\n                        }\n                        int result = Double.compare(ratingA, ratingB);\n                        return criteria.isSortDescending() ? -result : result;\n                    });\n                    break;\n\n                case \"duration\":\n                    content.sort((a, b) -> {\n                        if (a == null || b == null) return 0;\n                        int durationA = (a instanceof Movie) ? ((Movie) a).getDuration() : 0;\n                        int durationB = (b instanceof Movie) ? ((Movie) b).getDuration() : 0;\n                        int result = Integer.compare(durationA, durationB);\n                        return criteria.isSortDescending() ? -result : result;\n                    });\n                    break;\n\n                default:\n                    // Default to title sorting\n                    content.sort((a, b) -> {\n                        if (a == null || b == null) return 0;\n                        String titleA = a.getTitle() != null ? a.getTitle() : \"\";\n                        String titleB = b.getTitle() != null ? b.getTitle() : \"\";\n                        return titleA.compareToIgnoreCase(titleB);\n                    });\n            }\n            logger.debug(\"Sorting completed successfully\");\n        } catch (Exception e) {\n            logger.error(\"Error during sorting: {}\", e.getMessage(), e);\n            // Fall back to default sorting on error\n            try {\n                content.sort((a, b) -> {\n                    if (a == null || b == null) return 0;\n                    String titleA = a.getTitle() != null ? a.getTitle() : \"\";\n                    String titleB = b.getTitle() != null ? b.getTitle() : \"\";\n                    return titleA.compareToIgnoreCase(titleB);\n                });\n            } catch (Exception ex) {\n                logger.error(\"Error during fallback sorting: {}\", ex.getMessage(), ex);\n            }\n        }\n\n    }\n\n    /**\n     * Sorts a list of movies based on the specified criteria\n     *\n     * @param movies   The list of movies to sort\n     * @param criteria The sort criteria\n     */\n    private void sortMovies(List<Movie> movies, SearchCriteria criteria) {\n        if (movies == null || movies.isEmpty() || criteria == null) {\n            logger.debug(\"No movies to sort or invalid criteria\");\n            return;\n        }\n\n        String sortBy = criteria.getSortBy() != null ? criteria.getSortBy().toLowerCase() : \"title\";\n        logger.debug(\"Sorting {} movies by: {} {}\",\n                movies.size(),\n                sortBy,\n                criteria.isSortDescending() ? \"descending\" : \"ascending\");\n\n        try {\n            switch (sortBy) {\n                case \"title\":\n                    movies.sort((a, b) -> {\n                        if (a == null || b == null) return 0;\n                        String titleA = a.getTitle() != null ? a.getTitle() : \"\";\n                        String titleB = b.getTitle() != null ? b.getTitle() : \"\";\n                        int result = titleA.compareToIgnoreCase(titleB);\n                        return criteria.isSortDescending() ? -result : result;\n                    });\n                    break;\n\n                case \"year\":\n                    movies.sort((a, b) -> {\n                        if (a == null || b == null) return 0;\n                        int yearA = (a.getYear() != null) ? a.getYear().getYear() + 1900 : 0;\n                        int yearB = (b.getYear() != null) ? b.getYear().getYear() + 1900 : 0;\n                        int result = Integer.compare(yearA, yearB);\n                        return criteria.isSortDescending() ? -result : result;\n                    });\n                    break;\n\n                case \"rating\":\n                    movies.sort((a, b) -> {\n                        if (a == null || b == null) return 0;\n                        double ratingA = 0;\n                        double ratingB = 0;\n                        try {\n                            ratingA = a.getImdbRating();\n                            ratingB = b.getImdbRating();\n                        } catch (Exception e) {\n                            logger.warn(\"Error getting ratings: {}\", e.getMessage());\n                        }\n                        int result = Double.compare(ratingA, ratingB);\n                        return criteria.isSortDescending() ? -result : result;\n                    });\n                    break;\n\n                case \"duration\":\n                    movies.sort((a, b) -> {\n                        if (a == null || b == null) return 0;\n                        int durationA = 0;\n                        int durationB = 0;\n                        try {\n                            durationA = a.getDuration();\n                            durationB = b.getDuration();\n                        } catch (Exception e) {\n                            logger.warn(\"Error getting durations: {}\", e.getMessage());\n                        }\n                        int result = Integer.compare(durationA, durationB);\n                        return criteria.isSortDescending() ? -result : result;\n                    });\n                    break;\n\n                default:\n                    // Default to title sorting\n                    movies.sort((a, b) -> {\n                        if (a == null || b == null) return 0;\n                        String titleA = a.getTitle() != null ? a.getTitle() : \"\";\n                        String titleB = b.getTitle() != null ? b.getTitle() : \"\";\n                        return titleA.compareToIgnoreCase(titleB);\n                    });\n            }\n            logger.debug(\"Sorting movies completed successfully\");\n        } catch (Exception e) {\n            logger.error(\"Error during movie sorting: {}\", e.getMessage(), e);\n            // Fall back to default sorting on error\n            try {\n                movies.sort((a, b) -> {\n                    if (a == null || b == null) return 0;\n                    String titleA = a.getTitle() != null ? a.getTitle() : \"\";\n                    String titleB = b.getTitle() != null ? b.getTitle() : \"\";\n                    return titleA.compareToIgnoreCase(titleB);\n                });\n            } catch (Exception ex) {\n                logger.error(\"Error during fallback movie sorting: {}\", ex.getMessage(), ex);\n            }\n        }\n    }\n\n    /**\n     * Checks if the given content matches the search criteria\n     *\n     * @param content  The content to check\n     * @param criteria The search criteria to match against\n     * @return true if the content matches all criteria, false otherwise\n     */\n    private boolean matchesCriteria(Content content, SearchCriteria criteria) {\n        try {\n            // Null checks\n            if (content == null || criteria == null) {\n                logger.debug(\"Content or criteria is null\");\n                return false;\n            }\n\n            String contentTitle = content.getTitle() != null ? content.getTitle() : \"\";\n            String searchTitle = criteria.getTitle() != null ? criteria.getTitle().toLowerCase() : null;\n\n            // Title search with null safety and case-insensitive comparison\n            if (searchTitle != null && !contentTitle.toLowerCase().contains(searchTitle)) {\n                logger.debug(\"Filtered out '{}' by title: does not contain '{}'\", contentTitle, searchTitle);\n                return false;\n            }\n\n            // User rating range with error handling\n            try {\n                double avgUserRating = content.calculateAverageUserRating();\n                if (avgUserRating < criteria.getMinUserRating() || avgUserRating > criteria.getMaxUserRating()) {\n                    logger.debug(\"Filtered out '{}' by user rating: {} not in [{}, {}]\",\n                            contentTitle, avgUserRating, criteria.getMinUserRating(), criteria.getMaxUserRating());\n                    return false;\n                }\n            } catch (Exception e) {\n                logger.warn(\"Error calculating user rating for '{}': {}\", contentTitle, e.getMessage());\n                return false;\n            }\n\n            // Year range with null safety\n            if (criteria.hasYearFilter()) {\n                try {\n                    int contentYear = content.getYear() != null ? content.getYear().getYear() + 1900 : -1;\n                    Integer minYear = criteria.getMinYear();\n                    Integer maxYear = criteria.getMaxYear();\n\n                    if (contentYear == -1 ||\n                            (minYear != null && contentYear < minYear) ||\n                            (maxYear != null && contentYear > maxYear)) {\n                        logger.debug(\"Filtered out '{}' by year: {} not in [{}, {}]\",\n                                contentTitle, contentYear, minYear, maxYear);\n                        return false;\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"Error processing year filter for '{}': {}\", contentTitle, e.getMessage());\n                    return false;\n                }\n            }\n\n            // Duration range for movies only\n            if (criteria.hasDurationFilter() && content instanceof Movie movie) {\n                try {\n                    int duration = movie.getDuration();\n                    Integer minDuration = criteria.getMinDuration();\n                    Integer maxDuration = criteria.getMaxDuration();\n\n                    if ((minDuration != null && duration < minDuration) ||\n                            (maxDuration != null && duration > maxDuration)) {\n                        logger.debug(\"Filtered out '{}' by duration: {} not in [{}, {}]\",\n                                contentTitle, duration, minDuration, maxDuration);\n                        return false;\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"Error processing duration for '{}': {}\", contentTitle, e.getMessage());\n                    return false;\n                }\n            }\n\n            // Genre filter with null safety\n            if (criteria.hasGenreFilter()) {\n                try {\n                    List<Genre> contentGenres = content.getGenres();\n                    List<Genre> searchGenres = criteria.getGenres();\n\n                    boolean matches = contentGenres != null &&\n                            !contentGenres.isEmpty() &&\n                            searchGenres != null &&\n                            !searchGenres.isEmpty() &&\n                            contentGenres.stream()\n                                    .filter(Objects::nonNull)\n                                    .anyMatch(searchGenres::contains);\n\n                    if (!matches) {\n                        logger.debug(\"Filtered out '{}' by genre: {} does not match {}\",\n                                contentTitle, contentGenres, searchGenres);\n                        return false;\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"Error processing genres for '{}': {}\", contentTitle, e.getMessage());\n                    return false;\n                }\n            }\n\n            // IMDB rating range for movies only\n            if (criteria.hasRatingFilter() && content instanceof Movie movie) {\n                try {\n                    double imdbRating = movie.getImdbRating();\n                    double minRating = criteria.getMinImdbRating();\n                    double maxRating = criteria.getMaxImdbRating();\n\n                    if (imdbRating < minRating || imdbRating > maxRating) {\n                        logger.debug(\"Filtered out '{}' by IMDB rating: {} not in [{}, {}]\",\n                                contentTitle, imdbRating, minRating, maxRating);\n                        return false;\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"Error processing IMDB rating for '{}': {}\", contentTitle, e.getMessage());\n                    return false;\n                }\n            }\n\n            // Actor search for movies only\n            String actorName = criteria.getActorName();\n            if (actorName != null && !actorName.trim().isEmpty() && content instanceof Movie movie) {\n                try {\n                    List<Actor> actors = movie.getActors();\n                    String searchActor = actorName.toLowerCase().trim();\n\n                    boolean found = actors != null &&\n                            !actors.isEmpty() &&\n                            actors.stream()\n                                    .filter(Objects::nonNull)\n                                    .map(String::toLowerCase)\n                                    .anyMatch(actor -> actor.contains(searchActor));\n\n                    if (!found) {\n                        logger.debug(\"Filtered out '{}' by actor: no match for '{}'\", contentTitle, searchActor);\n                        return false;\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"Error processing actors for '{}': {}\", contentTitle, e.getMessage());\n                    return false;\n                }\n            }\n\n            // Director search for movies only\n            String directorName = criteria.getDirectorName();\n            if (directorName != null && !directorName.trim().isEmpty() && content instanceof Movie movie) {\n                try {\n                    String director = movie.getDirector();\n                    String searchDirector = directorName.toLowerCase().trim();\n\n                    if (director == null || !director.toLowerCase().contains(searchDirector)) {\n                        logger.debug(\"Filtered out '{}' by director: '{}' does not contain '{}'\",\n                                contentTitle, director, searchDirector);\n                        return false;\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"Error processing director for '{}': {}\", contentTitle, e.getMessage());\n                    return false;\n                }\n            }\n\n            // Description search for movies only\n            String descriptionText = criteria.getDescription();\n            if (descriptionText != null && !descriptionText.trim().isEmpty() && content instanceof Movie movie) {\n                try {\n                    String description = movie.getDescription();\n                    String searchText = descriptionText.toLowerCase().trim();\n\n                    if (description == null || !description.toLowerCase().contains(searchText)) {\n                        logger.debug(\"Filtered out '{}' by description: does not contain '{}'\", contentTitle, searchText);\n                        return false;\n                    }\n                } catch (Exception e) {\n                    logger.warn(\"Error processing description for '{}': {}\", contentTitle, e.getMessage());\n                    return false;\n                }\n            }\n\n            logger.debug(\"Accepted '{}' - matches all criteria\", contentTitle);\n            return true;\n\n        } catch (Exception e) {\n            logger.error(\"Unexpected error in matchesCriteria for '{}': {}\",\n                    content != null ? content.getTitle() : \"null\", e.getMessage(), e);\n            return false;\n        }\n    }\n\n    // Getters\n    public List<User> getUsers() {\n        return new ArrayList<>(users);\n    }\n\n    public List<Actor> getActors() {\n        return new ArrayList<>(actors);\n    }\n\n    public List<Director> getDirectors() {\n        return new ArrayList<>(directors);\n    }\n\n    public List<Movie> getMovies() {\n        return new ArrayList<>(movies);\n    }\n\n    public List<Series> getSeries() {\n        return new ArrayList<>(series);\n    }\n\n    public List<ForumPost> getForumPosts() {\n        return new ArrayList<>(forumPosts);\n    }\n\n    public boolean deleteForumPost(int postId) {\n        if (postId <= 0) {\n            return false;\n        }\n        synchronized (forumPostLock) {\n            return forumPosts.removeIf(post -> post.getId() == postId);\n        }\n    }\n\n    /**\n     * Searches for movie and series titles that contain the given search term (case-insensitive).\n     *\n     * @param searchTerm The term to search for in titles\n     * @return List of matching content titles\n     */\n    public List<String> searchTitles(String searchTerm) {\n        String lowerSearchTerm = searchTerm.toLowerCase();\n        List<String> results = new ArrayList<>();\n\n        // Search in movies\n        movies.stream()\n                .map(Movie::getTitle)\n                .filter(title -> title.toLowerCase().contains(lowerSearchTerm))\n                .forEach(results::add);\n\n        // Search in series\n        series.stream()\n                .map(Series::getTitle)\n                .filter(title -> title.toLowerCase().contains(lowerSearchTerm))\n                .forEach(results::add);\n\n        return results;\n    }\n\n    public int getNextSeasonId() {\n        return nextSeasonId;\n    }\n\n    public void setNextSeasonId(int nextSeasonId) {\n        this.nextSeasonId = nextSeasonId;\n    }\n\n    public int getNextEpisodeId() {\n        return nextEpisodeId;\n    }\n\n    public void setNextEpisodeId(int nextEpisodeId) {\n        this.nextEpisodeId = nextEpisodeId;\n    }\n\n    public List<Movie> searchMovies(SearchCriteria criteria) {\n        List<Movie> result = movies.stream()\n                .filter(movie -> matchesCriteria(movie, criteria))\n                .toList();\n\n        // Convert to ArrayList since toList() returns an unmodifiable list\n        List<Movie> modifiableResult = new ArrayList<>(result);\n\n        // Apply sorting if criteria has sorting parameters\n        if (criteria.getSortBy() != null && !criteria.getSortBy().isEmpty()) {\n            sortMovies(modifiableResult, criteria);\n        }\n\n        return modifiableResult;\n    }\n\n\n    public void setAllMovies(List<Movie> newMovies) {\n        if (newMovies != null) {\n            this.movies.clear();\n            this.movies.addAll(newMovies);\n        }\n    }\n\n    public void rateMovie(Movie selected, double rating) {\n        if (rating < 0.0 || rating > 10.0) {\n            throw new IllegalArgumentException(\"Rating must be between 0.0 and 10.0\");\n        }\n\n        // Find the movie in our collection\n        Movie movie = findMovieByTitle(selected.getTitle());\n        if (movie != null) {\n            // For simplicity, we'll use a fixed user ID (1) for now\n            // In a real application, this would be the current user's ID\n            int userId = 1;\n            movie.addUserRating(userId, (int) Math.round(rating));\n        }\n    }\n\n\n    public void setAllSeries(List<Series> newSeries) {\n        if (newSeries != null) {\n            this.series.clear();\n            this.series.addAll(newSeries);\n        }\n    }\n\n\n    public List<ForumPost> getAllForumPosts() {\n        synchronized (forumPostLock) {\n            return new ArrayList<>(forumPosts);\n        }\n    }\n\n    public void addForumPost(ForumPost post) {\n        if (post == null) {\n            throw new IllegalArgumentException(\"Forum post cannot be null\");\n        }\n        if (post.getTitle() == null || post.getTitle().trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Forum post title cannot be empty\");\n        }\n        if (post.getContent() == null || post.getContent().trim().isEmpty()) {\n            throw new IllegalArgumentException(\"Forum post content cannot be empty\");\n        }\n\n        synchronized (forumPostLock) {\n            // Ensure ID is not already in use\n            int newId = nextForumPostId++;\n            while (findForumPostById(newId) != null) {\n                newId = nextForumPostId++;\n            }\n            post.setId(newId);\n\n            // Set timestamps if not already set\n            if (post.getCreatedAt() == null) {\n                post.setCreatedAt(LocalDateTime.now());\n            }\n            if (post.getUpdatedAt() == null) {\n                post.setUpdatedAt(post.getCreatedAt());\n            }\n\n            forumPosts.add(post);\n            logger.debug(\"Added new forum post with ID: {}\", newId);\n        }\n    }\n\n    public boolean removeForumPost(ForumPost post) {\n        if (post == null) {\n            return false;\n        }\n        synchronized (forumPostLock) {\n            boolean removed = forumPosts.remove(post);\n            if (removed) {\n                logger.debug(\"Removed forum post with ID: {}\", post.getIdSanitized());\n            } else {\n                logger.warn(\"Attempted to remove non-existent forum post: {}\", post.getIdSanitized());\n            }\n            return removed;\n        }\n    }\n\n    public ForumPost findForumPostById(int id) {\n        if (id <= 0) {\n            return null;\n        }\n        synchronized (forumPostLock) {\n            return forumPosts.stream()\n                    .filter(post -> post.getId() == id)\n                    .findFirst()\n                    .orElse(null);\n        }\n    }\n\n    public void upvoteForumPost(int postId, int userId) {\n        if (postId <= 0 || userId <= 0) {\n            throw new IllegalArgumentException(\"Invalid post ID or user ID\");\n        }\n        synchronized (forumPostLock) {\n            ForumPost post = findForumPostById(postId);\n            if (post != null) {\n                post.upvote(userId);\n                post.setUpdatedAt(LocalDateTime.now());\n                logger.debug(\"User {} upvoted post {}\", userId, postId);\n            } else {\n                logger.warn(\"Attempted to upvote non-existent post: {}\", postId);\n            }\n        }\n    }\n\n    public void downvoteForumPost(int postId, int userId) {\n        if (postId <= 0 || userId <= 0) {\n            throw new IllegalArgumentException(\"Invalid post ID or user ID\");\n        }\n        synchronized (forumPostLock) {\n            ForumPost post = findForumPostById(postId);\n            if (post != null) {\n                post.downvote(userId);\n                post.setUpdatedAt(LocalDateTime.now());\n                logger.debug(\"User {} downvoted post {}\", userId, postId);\n            } else {\n                logger.warn(\"Attempted to downvote non-existent post: {}\", postId);\n            }\n        }\n    }\n\n    /**\n     * Parses a CSV line handling quoted fields properly\n     *\n     * @param line the CSV line to parse\n     * @return array of parsed fields\n     */\n    private String[] parseCSVLine(String line) {\n        List<String> fields = new ArrayList<>();\n        StringBuilder currentField = new StringBuilder();\n        boolean inQuotes = false;\n\n        for (int i = 0; i < line.length(); i++) {\n            char c = line.charAt(i);\n\n            if (c == '\"') {\n                inQuotes = !inQuotes;\n                currentField.append(c); // Keep the quotes for now, we'll remove them later\n            } else if (c == ',' && !inQuotes) {\n                fields.add(currentField.toString().trim());\n                currentField = new StringBuilder();\n            } else {\n                currentField.append(c);\n            }\n        }\n\n        // Add the last field\n        fields.add(currentField.toString().trim());\n\n        return fields.toArray(new String[0]);\n    }\n\n    public List<User> getAllUsers() {\n        return new ArrayList<>(users);\n    }\n\n    public List<Actor> getAllActors() {\n        return new ArrayList<>(actors);\n    }\n\n    public List<Director> getAllDirectors() {\n        return new ArrayList<>(directors);\n    }\n\n    public List<Movie> getAllMovies() {\n        return new ArrayList<>(movies);\n    }\n\n    public List<Series> getAllSeries() {\n        return new ArrayList<>(series);\n    }\n\n}\n",
                    "language": "java"
                },
                "codebaseEnabled": true
            },
            "createdAt": 1754580707144,
            "isInternal": false,
            "rawContent": {
                "type": "doc",
                "content": [
                    {
                        "type": "paragraph",
                        "content": [
                            {
                                "type": "command",
                                "attrs": {
                                    "label": "fix"
                                },
                                "content": [
                                    {
                                        "type": "text",
                                        "text": "fix: "
                                    }
                                ]
                            },
                            {
                                "type": "codeBlock",
                                "attrs": {
                                    "language": "java"
                                },
                                "content": [
                                    {
                                        "type": "text",
                                        "text": "actor.contains(searchActor)"
                                    }
                                ]
                            },
                            {
                                "type": "text",
                                "text": "Cannot resolve method 'contains' in 'Object'"
                            }
                        ]
                    }
                ]
            },
            "autoAppliedRules": [
                {
                    "name": "Repository Information Overview",
                    "description": "Repository Information Overview",
                    "uri": "zen-rules://repo/repo",
                    "mimeType": "text/markdown",
                    "content": "--\r\n\r\n# IMDB Clone Information\r\n\r\n## Summary\r\nA JavaFX-based application that simulates an IMDB-like movie and TV series database. The application allows users to browse, search, and rate movies and TV series.\r\n\r\n## Structure\r\n- `src/main/java`: Contains all Java source code\r\n- `src/main/resources`: Contains application resources including data files\r\n- `src/test`: Contains test files\r\n- `.mvn`: Maven wrapper files\r\n\r\n## Language & Runtime\r\n**Language**: Java\r\n**Version**: Java 21\r\n**Build System**: Maven\r\n**Package Manager**: Maven\r\n\r\n## Dependencies\r\n**Main Dependencies**:\r\n- JavaFX (21.0.3): Controls, FXML, Graphics, Media, Web modules\r\n- ControlsFX (11.2.1): Additional JavaFX controls\r\n\r\n**Development Dependencies**:\r\n- JUnit Jupiter (5.10.2): Testing framework\r\n\r\n## Build & Installation\r\n```bash\r\nmvn clean install\r\nmvn javafx:run\r\n```\r\n\r\n## Project Structure\r\nThe application follows an MVC-like architecture:\r\n\r\n### Model\r\n- `model/Content.java`: Abstract base class for all media content\r\n- `model/Movie.java`: Represents a movie with title, year, genre, etc.\r\n- `model/Series.java`: Represents a TV series with seasons and episodes\r\n- `model/Actor.java`, `model/Director.java`: Represent people involved in productions\r\n- `model/User.java`: Represents application users\r\n\r\n### Data Management\r\n- `data/DataManager.java`: Central class for data loading and management\r\n- `data/SearchCriteria.java`: Used for filtering content in searches\r\n\r\n### View/Controller\r\n- `gui/MovieManagementGUI.java`: Main JavaFX application UI\r\n\r\n### Enums & Exceptions\r\n- `enums/Genre.java`: Enumeration of content genres\r\n- Various exception classes for error handling\r\n\r\n## Issues Fixed\r\n1. Fixed parameter mismatch in Content constructor\r\n2. Implemented Movie constructors to match usage in DataManager\r\n3. Fixed DataManager's loadMovies method\r\n4. Implemented searchMovies method that was returning null\r\n5. Fixed getAllMovies and getAllSeries methods\r\n6. Implemented rateMovie functionality\r\n7. Created missing data directory and sample data files\r\n8. Updated module-info.java with required exports\r\n9. Created main application class\r\n10. Fixed pom.xml configuration",
                    "alwaysApply": true
                }
            ]
        },
        {
            "id": "6b44d0ee-5631-486d-b804-fce691bdc03c",
            "role": "assistant",
            "content": [
                {
                    "type": "text",
                    "text": "I can see the issue. The error occurs because `actor` is of type `Object` instead of the expected `Actor` type. Let me first examine the code to understand the context better."
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_012nE9tDgqvKieJCj21Jvbet",
                    "title": "Fulltext search",
                    "statusText": "Done",
                    "status": "SUCCESS",
                    "isHidden": false
                },
                {
                    "type": "text",
                    "text": "Let me examine the specific method where this error occurs:"
                },
                {
                    "type": "toolCall",
                    "toolCallId": "toolu_01Pkyubyb4cnDk9XQ6vkEw2w",
                    "statusText": "Viewed file (lines 820:859)",
                    "status": "SUCCESS",
                    "context": {
                        "files": [
                            {
                                "path": "src/main/java/com/papel/imdb_clone/data/DataManager.java",
                                "fsPath": "C:/Users/mas_b/IdeaProjects/imdb_clone/src/main/java/com/papel/imdb_clone/data/DataManager.java"
                            }
                        ]
                    },
                    "isHidden": false
                }
            ],
            "context": {
                "author": "Coding Agent",
                "operationId": "27c8ea63-29b4-4b1b-a1c6-ec63e6bd6d56"
            },
            "createdAt": 1754580711266,
            "isInternal": false
        }
    ],
    "isAgent": true,
    "isCustomAgent": false,
    "isUnitTestsAgent": false,
    "isE2EAgent": false,
    "isQnaAgent": false,
    "isRepoInfoAgent": false
}
}