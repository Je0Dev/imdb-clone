{
    "checksum": "6f9326018e5ebed4a0e9258fac7ccdf8b6aea7c17dd28fe079dfd9e658a06089",
    "data": {
    "id": "7f29f4cf-ead0-4bce-810d-6756ca6f3868",
    "createdAt": 1754384108711,
    "updatedAt": 1754384245943,
    "title": "Make improvements to the project",
    "messages": [
        {
            "id": "ae3177c4-1bde-49ce-85b7-10ff7ec9dc67",
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Make improvements to the project"
                }
            ],
            "context": {
                "currentFile": {
                    "path": "src\\main\\java\\com\\papel\\imdb_clone\\data\\DataManager.java",
                    "fsPath": "C:\\Users\\mas_b\\IdeaProjects\\imdb_clone\\src\\main\\java\\com\\papel\\imdb_clone\\data\\DataManager.java",
                    "sources": [
                        "opened_tab"
                    ],
                    "content": "package com.papel.imdb_clone.data;\r\n\r\nimport com.papel.imdb_clone.enums.Genre;\r\nimport com.papel.imdb_clone.exceptions.DuplicateContentException;\r\nimport com.papel.imdb_clone.exceptions.DuplicateUsernameException;\r\nimport com.papel.imdb_clone.exceptions.FileParsingException;\r\nimport com.papel.imdb_clone.model.*;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.time.LocalDate;\r\nimport java.time.format.DateTimeFormatter;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\n\r\npublic class DataManager {\r\n    private final List<User> users;\r\n    private final List<Actor> actors;\r\n    private final List<Director> directors;\r\n    private final List<Movie> movies;\r\n    private final List<Series> series;\r\n\r\n    private int nextUserId = 1;\r\n    private int nextActorId = 1;\r\n    private int nextDirectorId = 1;\r\n    private int nextMovieId = 1;\r\n    private int nextSeriesId = 1;\r\n    private int nextSeasonId = 1;\r\n    private int nextEpisodeId = 1;\r\n\r\n    // We don't need separate allMovies and allSeries fields since we already have movies and series lists\r\n\r\n    /**\r\n     * Initializes a new instance of the DataManager class.\r\n     * This constructor sets up empty lists for users, actors, directors, movies, and series.\r\n     */\r\n    public DataManager() {\r\n        this.users = new ArrayList<>();\r\n        this.actors = new ArrayList<>();\r\n\r\n        this.directors = new ArrayList<>();\r\n        this.movies = new ArrayList<>();\r\n        this.series = new ArrayList<>();\r\n    }\r\n\r\n\r\n    public void loadAllData() {\r\n        loadUsers(\"users.txt\");\r\n        loadActors(\"actors.txt\");\r\n        loadDirectors(\"directors.txt\");\r\n        loadMovies(\"movies.txt\");\r\n        loadSeries(\"series.txt\");\r\n    }\r\n\r\n    public void loadUsers(String filename) {\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                String[] parts = parseCSVLine(line);\r\n                if (parts.length >= 6) {\r\n                    // Handle the case where middle name/nickname is quoted\r\n                    // Format: firstName,middleName/nickname,lastName,gender,nationality,username\r\n                    String firstName = parts[0];\r\n                    String middleName = parts[1].replaceAll(\"\\\"\", \"\"); // Remove quotes\r\n                    String lastName = parts[2];\r\n                    char gender = parts[3].charAt(0);\r\n                    String nationality = parts[4];\r\n                    String username = parts[5];\r\n\r\n                    // Combine names appropriately\r\n                    String fullFirstName = middleName.isEmpty() ? firstName : firstName + \" \" + middleName;\r\n                    User user = new User(fullFirstName, lastName, username, gender, nationality);\r\n                    user.setId(nextUserId++);\r\n                    users.add(user);\r\n                } else if (parts.length >= 5) {\r\n                    // Standard format: firstName,lastName,username,gender,nationality\r\n                    User user = new User(parts[0], parts[1], parts[2], parts[3].charAt(0), parts[4]);\r\n                    user.setId(nextUserId++);\r\n                    users.add(user);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            throw new FileParsingException(\"Error loading users: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public void loadActors(String filename) {\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                String[] parts = parseCSVLine(line);\r\n                if (parts.length >= 6) {\r\n                    // Handle the case where middle name/nickname is quoted\r\n                    // Format: firstName,middleName/nickname,lastName,birthDate,gender,nationality\r\n                    String firstName = parts[0];\r\n                    String middleName = parts[1].replaceAll(\"\\\"\", \"\"); // Remove quotes\r\n                    String lastName = parts[2];\r\n                    LocalDate birthDate = LocalDate.parse(parts[3], DateTimeFormatter.ISO_LOCAL_DATE);\r\n                    char gender = parts[4].charAt(0);\r\n                    String nationality = parts[5];\r\n\r\n                    // Combine names appropriately\r\n                    String fullFirstName = middleName.isEmpty() ? firstName : firstName + \" \" + middleName;\r\n                    Actor actor = new Actor(fullFirstName, lastName, birthDate, gender, nationality);\r\n                    actor.setId(nextActorId++);\r\n                    actors.add(actor);\r\n                } else if (parts.length >= 5) {\r\n                    // Standard format: firstName,lastName,birthDate,gender,nationality\r\n                    LocalDate birthDate = LocalDate.parse(parts[2], DateTimeFormatter.ISO_LOCAL_DATE);\r\n                    Actor actor = new Actor(parts[0], parts[1], birthDate, parts[3].charAt(0), parts[4]);\r\n                    actor.setId(nextActorId++);\r\n                    actors.add(actor);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            throw new FileParsingException(\"Error loading actors: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public void loadDirectors(String filename) {\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                String[] parts = parseCSVLine(line);\r\n                if (parts.length >= 5) {\r\n                    // Handle the case where middle name/nickname is quoted\r\n                    // Format: firstName,middleName/nickname,lastName,birthDate,gender\r\n                    String firstName = parts[0];\r\n                    String middleName = parts[1].replaceAll(\"\\\"\", \"\"); // Remove quotes\r\n                    String lastName = parts[2];\r\n                    LocalDate birthDate = LocalDate.parse(parts[3], DateTimeFormatter.ISO_LOCAL_DATE);\r\n                    char gender = parts[4].charAt(0);\r\n\r\n                    // Combine names appropriately\r\n                    String fullFirstName = middleName.isEmpty() ? firstName : firstName + \" \" + middleName;\r\n                    Director director = new Director(fullFirstName, lastName, birthDate, gender);\r\n                    director.setId(nextDirectorId++);\r\n                    directors.add(director);\r\n                } else if (parts.length >= 4) {\r\n                    // Standard format: firstName,lastName,birthDate,gender\r\n                    LocalDate birthDate = LocalDate.parse(parts[2], DateTimeFormatter.ISO_LOCAL_DATE);\r\n                    Director director = new Director(parts[0], parts[1], birthDate, parts[3].charAt(0));\r\n                    director.setId(nextDirectorId++);\r\n                    directors.add(director);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            throw new FileParsingException(\"Error loading directors: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public void loadMovies(String filename) {\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                String[] parts = parseCSVLine(line);\r\n                if (parts.length >= 6) {\r\n                    String title = parts[0];\r\n                    int year = Integer.parseInt(parts[1]);\r\n                    Genre genre = Genre.valueOf(parts[2].toUpperCase().replace(\" \", \"_\"));\r\n                    int duration = Integer.parseInt(parts[3]);\r\n                    Director director = findDirectorByName(parts[4]);\r\n                    double imdbRating = Double.parseDouble(parts[5]);\r\n\r\n                    List<Actor> movieActors = new ArrayList<>();\r\n                    if (parts.length > 6) {\r\n                        String[] actorNames = parts[6].split(\";\");\r\n                        for (String actorName : actorNames) {\r\n                            Actor actor = findActorByName(actorName.trim());\r\n                            if (actor != null) {\r\n                                movieActors.add(actor);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Handle case where director might be null\r\n                    Movie movie;\r\n                    if (director != null) {\r\n                        movie = new Movie(title, year, director, null, duration, movieActors);\r\n                    } else {\r\n                        // Create a movie with genre and director name from the file when director object is not found\r\n                        movie = new Movie(title, year, genre.name(), parts[4], new HashMap<>());\r\n                        movie.setActors(movieActors);\r\n                    }\r\n                    movie.setId(nextMovieId++);\r\n                    movie.setImdbRating(imdbRating);\r\n                    movies.add(movie);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            throw new FileParsingException(\"Error loading movies: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public void loadSeries(String filename) {\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                String[] parts = parseCSVLine(line);\r\n                if (parts.length >= 2) {\r\n                    String title = parts[0];\r\n                    Genre genre = Genre.valueOf(parts[1].toUpperCase().replace(\" \", \"_\"));\r\n\r\n                    Series series = new Series(title);\r\n                    series.setGenre(genre);  // Set the genre from the file\r\n                    series.setId(nextSeriesId++);\r\n                    this.series.add(series);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            throw new FileParsingException(\"Error loading series: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public void addUser(User user) {\r\n        if (findUserByUsername(user.getUsername()) != null) {\r\n            throw new DuplicateUsernameException(\"Username already exists: \" + user.getUsername());\r\n        }\r\n        user.setId(nextUserId++);\r\n        users.add(user);\r\n    }\r\n\r\n    public void addActor(Actor actor) {\r\n        actor.setId(nextActorId++);\r\n        actors.add(actor);\r\n    }\r\n\r\n    public void addDirector(Director director) {\r\n        director.setId(nextDirectorId++);\r\n        directors.add(director);\r\n    }\r\n\r\n    public void addMovie(Movie movie) {\r\n        if (findMovieByTitle(movie.getTitle()) != null) {\r\n            throw new DuplicateContentException(\"Movie already exists: \" + movie.getTitle());\r\n        }\r\n        movie.setId(nextMovieId++);\r\n        movies.add(movie);\r\n    }\r\n\r\n    public void addSeries(Series series) {\r\n        if (findSeriesByTitle(series.getTitle()) != null) {\r\n            throw new DuplicateContentException(\"Series already exists: \" + series.getTitle());\r\n        }\r\n        series.setId(nextSeriesId++);\r\n        this.series.add(series);\r\n    }\r\n\r\n    public void removeMovie(Movie movie) {\r\n        if (movie == null) {\r\n            throw new IllegalArgumentException(\"Movie cannot be null\");\r\n        }\r\n        boolean removed = movies.remove(movie);\r\n        if (!removed) {\r\n            throw new IllegalArgumentException(\"Movie not found in collection: \" + movie.getTitle());\r\n        }\r\n    }\r\n\r\n    public void removeSeries(Series series) {\r\n        if (series == null) {\r\n            throw new IllegalArgumentException(\"Series cannot be null\");\r\n        }\r\n        boolean removed = this.series.remove(series);\r\n        if (!removed) {\r\n            throw new IllegalArgumentException(\"Series not found in collection: \" + series.getTitle());\r\n        }\r\n    }\r\n\r\n    public User findUserByUsername(String username) {\r\n        return users.stream()\r\n                .filter(user -> user.getUsername().equals(username))\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n    public Actor findActorByName(String name) {\r\n        return actors.stream()\r\n                .filter(actor -> actor.getFullName().equals(name))\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n    public Director findDirectorByName(String name) {\r\n        return directors.stream()\r\n                .filter(director -> director.getFullName().equals(name))\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n    public Movie findMovieByTitle(String title) {\r\n        return movies.stream()\r\n                .filter(movie -> movie.getTitle().equals(title))\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n    public Series findSeriesByTitle(String title) {\r\n        return series.stream()\r\n                .filter(series -> series.getTitle().equals(title))\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n    public List<Content> searchContent(SearchCriteria criteria) {\r\n        List<Content> result = new ArrayList<>();\r\n\r\n        // Search movies\r\n        result.addAll(movies.stream()\r\n                .filter(movie -> matchesCriteria(movie, criteria))\r\n                .toList());\r\n\r\n        // Search series\r\n        result.addAll(series.stream()\r\n                .filter(series -> matchesCriteria(series, criteria))\r\n                .toList());\r\n\r\n        // Apply sorting\r\n        sortContent(result, criteria);\r\n\r\n        return result;\r\n    }\r\n\r\n    private void sortContent(List<Content> content, SearchCriteria criteria) {\r\n        if (content.isEmpty()) return;\r\n\r\n        switch (criteria.getSortBy().toLowerCase()) {\r\n            case \"title\":\r\n                content.sort((a, b) -> criteria.isSortDescending()\r\n                        ? b.getTitle().compareToIgnoreCase(a.getTitle())\r\n                        : a.getTitle().compareToIgnoreCase(b.getTitle()));\r\n                break;\r\n            case \"year\":\r\n                content.sort((a, b) -> {\r\n                    int yearA = a.getYear().getYear() + 1900;\r\n                    int yearB = b.getYear().getYear() + 1900;\r\n                    return criteria.isSortDescending()\r\n                            ? Integer.compare(yearB, yearA)\r\n                            : Integer.compare(yearA, yearB);\r\n                });\r\n                break;\r\n            case \"rating\":\r\n                content.sort((a, b) -> {\r\n                    double ratingA = a instanceof Movie ? ((Movie) a).getImdbRating() : a.calculateAverageUserRating();\r\n                    double ratingB = b instanceof Movie ? ((Movie) b).getImdbRating() : b.calculateAverageUserRating();\r\n                    return criteria.isSortDescending()\r\n                            ? Double.compare(ratingB, ratingA)\r\n                            : Double.compare(ratingA, ratingB);\r\n                });\r\n                break;\r\n            case \"duration\":\r\n                content.sort((a, b) -> {\r\n                    int durationA = a instanceof Movie ? ((Movie) a).getDuration() : 0;\r\n                    int durationB = b instanceof Movie ? ((Movie) b).getDuration() : 0;\r\n                    return criteria.isSortDescending()\r\n                            ? Integer.compare(durationB, durationA)\r\n                            : Integer.compare(durationA, durationB);\r\n                });\r\n                break;\r\n            default:\r\n                // Default to title sorting\r\n                content.sort((a, b) -> a.getTitle().compareToIgnoreCase(b.getTitle()));\r\n        }\r\n    }\r\n\r\n    private void sortMovies(List<Movie> movies, SearchCriteria criteria) {\r\n        if (movies.isEmpty()) return;\r\n\r\n        switch (criteria.getSortBy().toLowerCase()) {\r\n            case \"title\":\r\n                movies.sort((a, b) -> criteria.isSortDescending()\r\n                        ? b.getTitle().compareToIgnoreCase(a.getTitle())\r\n                        : a.getTitle().compareToIgnoreCase(b.getTitle()));\r\n                break;\r\n            case \"year\":\r\n                movies.sort((a, b) -> {\r\n                    int yearA = a.getYear().getYear() + 1900;\r\n                    int yearB = b.getYear().getYear() + 1900;\r\n                    return criteria.isSortDescending()\r\n                            ? Integer.compare(yearB, yearA)\r\n                            : Integer.compare(yearA, yearB);\r\n                });\r\n                break;\r\n            case \"rating\":\r\n                movies.sort((a, b) -> {\r\n                    double ratingA = a.getImdbRating();\r\n                    double ratingB = b.getImdbRating();\r\n                    return criteria.isSortDescending()\r\n                            ? Double.compare(ratingB, ratingA)\r\n                            : Double.compare(ratingA, ratingB);\r\n                });\r\n                break;\r\n            case \"duration\":\r\n                movies.sort((a, b) -> {\r\n                    int durationA = a.getDuration();\r\n                    int durationB = b.getDuration();\r\n                    return criteria.isSortDescending()\r\n                            ? Integer.compare(durationB, durationA)\r\n                            : Integer.compare(durationA, durationB);\r\n                });\r\n                break;\r\n            default:\r\n                // Default to title sorting\r\n                movies.sort((a, b) -> a.getTitle().compareToIgnoreCase(b.getTitle()));\r\n        }\r\n    }\r\n\r\n    private boolean matchesCriteria(Content content, SearchCriteria criteria) {\r\n        // Title search\r\n        if (criteria.getTitle() != null && !content.getTitle().toLowerCase().contains(criteria.getTitle().toLowerCase())) {\r\n            return false;\r\n        }\r\n\r\n        // User rating range\r\n        double avgUserRating = content.calculateAverageUserRating();\r\n        if (avgUserRating < criteria.getMinUserRating() || avgUserRating > criteria.getMaxUserRating()) {\r\n            return false;\r\n        }\r\n\r\n        // Year range\r\n        if (criteria.hasYearFilter()) {\r\n            int contentYear = content.getYear().getYear() + 1900;\r\n            if (criteria.getMinYear() != null && contentYear < criteria.getMinYear()) {\r\n                return false;\r\n            }\r\n            if (criteria.getMaxYear() != null && contentYear > criteria.getMaxYear()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Genre filter\r\n        if (criteria.hasGenreFilter()) {\r\n            if (content instanceof Movie movie) {\r\n                boolean hasMatchingGenre = criteria.getGenres().stream()\r\n                        .anyMatch(genre -> movie.hasGenre(genre) || movie.getGenre().equals(genre));\r\n                if (!hasMatchingGenre) return false;\r\n            } else {\r\n                // For non-movie content, check primary genre\r\n                if (!criteria.getGenres().contains(content.getGenre())) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Movie-specific criteria\r\n        if (content instanceof Movie movie) {\r\n            // IMDB rating range\r\n            if (movie.getImdbRating() < criteria.getMinImdbRating() ||\r\n                    movie.getImdbRating() > criteria.getMaxImdbRating()) {\r\n                return false;\r\n            }\r\n\r\n            // Duration range\r\n            if (criteria.hasDurationFilter()) {\r\n                if (criteria.getMinDuration() != null && movie.getDuration() < criteria.getMinDuration()) {\r\n                    return false;\r\n                }\r\n                if (criteria.getMaxDuration() != null && movie.getDuration() > criteria.getMaxDuration()) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // Actor search\r\n            if (criteria.getActorName() != null) {\r\n                boolean hasActor = movie.getActors().stream()\r\n                        .anyMatch(actor -> actor.getFullName().toLowerCase().contains(criteria.getActorName().toLowerCase()));\r\n                if (!hasActor) return false;\r\n            }\r\n\r\n            // Director search\r\n            if (criteria.getDirectorName() != null) {\r\n                if (movie.getDirector() == null ||\r\n                        !movie.getDirector().toLowerCase().contains(criteria.getDirectorName().toLowerCase())) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // Description search\r\n            if (criteria.getDescription() != null) {\r\n                String description = movie.getDescription();\r\n                return description != null &&\r\n                        description.toLowerCase().contains(criteria.getDescription().toLowerCase());\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Getters\r\n    public List<User> getUsers() {\r\n        return new ArrayList<>(users);\r\n    }\r\n\r\n    public List<Actor> getActors() {\r\n        return new ArrayList<>(actors);\r\n    }\r\n\r\n    public List<Director> getDirectors() {\r\n        return new ArrayList<>(directors);\r\n    }\r\n\r\n    public List<Movie> getMovies() {\r\n        return new ArrayList<>(movies);\r\n    }\r\n\r\n    public List<Series> getSeries() {\r\n        return new ArrayList<>(series);\r\n    }\r\n\r\n    public int getNextSeasonId() {\r\n        return nextSeasonId;\r\n    }\r\n\r\n    public void setNextSeasonId(int nextSeasonId) {\r\n        this.nextSeasonId = nextSeasonId;\r\n    }\r\n\r\n    public int getNextEpisodeId() {\r\n        return nextEpisodeId;\r\n    }\r\n\r\n    public void setNextEpisodeId(int nextEpisodeId) {\r\n        this.nextEpisodeId = nextEpisodeId;\r\n    }\r\n\r\n    public List<Movie> searchMovies(SearchCriteria criteria) {\r\n        List<Movie> result = movies.stream()\r\n                .filter(movie -> matchesCriteria(movie, criteria))\r\n                .toList();\r\n\r\n        // Convert to ArrayList since toList() returns an unmodifiable list\r\n        List<Movie> modifiableResult = new ArrayList<>(result);\r\n\r\n        // Apply sorting if criteria has sorting parameters\r\n        if (criteria.getSortBy() != null && !criteria.getSortBy().isEmpty()) {\r\n            sortMovies(modifiableResult, criteria);\r\n        }\r\n\r\n        return modifiableResult;\r\n    }\r\n\r\n    public List<Movie> getAllMovies() {\r\n        return new ArrayList<>(movies);\r\n    }\r\n\r\n    public void setAllMovies(List<Movie> newMovies) {\r\n        if (newMovies != null) {\r\n            this.movies.clear();\r\n            this.movies.addAll(newMovies);\r\n        }\r\n    }\r\n\r\n    public void rateMovie(Movie selected, double rating) {\r\n        if (rating < 0.0 || rating > 10.0) {\r\n            throw new IllegalArgumentException(\"Rating must be between 0.0 and 10.0\");\r\n        }\r\n\r\n        // Find the movie in our collection\r\n        Movie movie = findMovieByTitle(selected.getTitle());\r\n        if (movie != null) {\r\n            // For simplicity, we'll use a fixed user ID (1) for now\r\n            // In a real application, this would be the current user's ID\r\n            int userId = 1;\r\n            movie.addUserRating(userId, (int) Math.round(rating));\r\n        }\r\n    }\r\n\r\n    public List<Series> getAllSeries() {\r\n        return new ArrayList<>(series);\r\n    }\r\n\r\n    public List<Actor> getAllActors() {\r\n        return new ArrayList<>(actors);\r\n    }\r\n\r\n    public void setAllSeries(List<Series> newSeries) {\r\n        if (newSeries != null) {\r\n            this.series.clear();\r\n            this.series.addAll(newSeries);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses a CSV line handling quoted fields properly\r\n     *\r\n     * @param line the CSV line to parse\r\n     * @return array of parsed fields\r\n     */\r\n    private String[] parseCSVLine(String line) {\r\n        List<String> fields = new ArrayList<>();\r\n        StringBuilder currentField = new StringBuilder();\r\n        boolean inQuotes = false;\r\n\r\n        for (int i = 0; i < line.length(); i++) {\r\n            char c = line.charAt(i);\r\n\r\n            if (c == '\"') {\r\n                inQuotes = !inQuotes;\r\n                currentField.append(c); // Keep the quotes for now, we'll remove them later\r\n            } else if (c == ',' && !inQuotes) {\r\n                fields.add(currentField.toString().trim());\r\n                currentField = new StringBuilder();\r\n            } else {\r\n                currentField.append(c);\r\n            }\r\n        }\r\n\r\n        // Add the last field\r\n        fields.add(currentField.toString().trim());\r\n\r\n        return fields.toArray(new String[0]);\r\n    }\r\n}\r\n"
                },
                "codebaseEnabled": true
            },
            "createdAt": 1754384108731,
            "isInternal": false,
            "rawContent": {
                "type": "doc",
                "content": [
                    {
                        "type": "paragraph",
                        "content": [
                            {
                                "type": "text",
                                "text": "Make improvements to the project"
                            }
                        ]
                    }
                ]
            },
            "autoAppliedRules": []
        },
        {
            "id": "1af76eba-2c33-4cf6-9b2e-91f1c17b5fd0",
            "role": "user",
            "content": [
                {
                    "type": "text",
                    "text": "Make improvements to the whole projects"
                }
            ],
            "context": {
                "currentFile": {
                    "path": "src\\main\\java\\com\\papel\\imdb_clone\\data\\DataManager.java",
                    "fsPath": "C:\\Users\\mas_b\\IdeaProjects\\imdb_clone\\src\\main\\java\\com\\papel\\imdb_clone\\data\\DataManager.java",
                    "sources": [
                        "opened_tab"
                    ],
                    "content": "package com.papel.imdb_clone.data;\r\n\r\nimport com.papel.imdb_clone.enums.Genre;\r\nimport com.papel.imdb_clone.exceptions.DuplicateContentException;\r\nimport com.papel.imdb_clone.exceptions.DuplicateUsernameException;\r\nimport com.papel.imdb_clone.exceptions.FileParsingException;\r\nimport com.papel.imdb_clone.model.*;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.FileReader;\r\nimport java.io.IOException;\r\nimport java.time.LocalDate;\r\nimport java.time.format.DateTimeFormatter;\r\nimport java.util.ArrayList;\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\n\r\npublic class DataManager {\r\n    private final List<User> users;\r\n    private final List<Actor> actors;\r\n    private final List<Director> directors;\r\n    private final List<Movie> movies;\r\n    private final List<Series> series;\r\n\r\n    private int nextUserId = 1;\r\n    private int nextActorId = 1;\r\n    private int nextDirectorId = 1;\r\n    private int nextMovieId = 1;\r\n    private int nextSeriesId = 1;\r\n    private int nextSeasonId = 1;\r\n    private int nextEpisodeId = 1;\r\n\r\n    // We don't need separate allMovies and allSeries fields since we already have movies and series lists\r\n\r\n    /**\r\n     * Initializes a new instance of the DataManager class.\r\n     * This constructor sets up empty lists for users, actors, directors, movies, and series.\r\n     */\r\n    public DataManager() {\r\n        this.users = new ArrayList<>();\r\n        this.actors = new ArrayList<>();\r\n\r\n        this.directors = new ArrayList<>();\r\n        this.movies = new ArrayList<>();\r\n        this.series = new ArrayList<>();\r\n    }\r\n\r\n\r\n    public void loadAllData() {\r\n        loadUsers(\"users.txt\");\r\n        loadActors(\"actors.txt\");\r\n        loadDirectors(\"directors.txt\");\r\n        loadMovies(\"movies.txt\");\r\n        loadSeries(\"series.txt\");\r\n    }\r\n\r\n    public void loadUsers(String filename) {\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                String[] parts = parseCSVLine(line);\r\n                if (parts.length >= 6) {\r\n                    // Handle the case where middle name/nickname is quoted\r\n                    // Format: firstName,middleName/nickname,lastName,gender,nationality,username\r\n                    String firstName = parts[0];\r\n                    String middleName = parts[1].replaceAll(\"\\\"\", \"\"); // Remove quotes\r\n                    String lastName = parts[2];\r\n                    char gender = parts[3].charAt(0);\r\n                    String nationality = parts[4];\r\n                    String username = parts[5];\r\n\r\n                    // Combine names appropriately\r\n                    String fullFirstName = middleName.isEmpty() ? firstName : firstName + \" \" + middleName;\r\n                    User user = new User(fullFirstName, lastName, username, gender, nationality);\r\n                    user.setId(nextUserId++);\r\n                    users.add(user);\r\n                } else if (parts.length >= 5) {\r\n                    // Standard format: firstName,lastName,username,gender,nationality\r\n                    User user = new User(parts[0], parts[1], parts[2], parts[3].charAt(0), parts[4]);\r\n                    user.setId(nextUserId++);\r\n                    users.add(user);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            throw new FileParsingException(\"Error loading users: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public void loadActors(String filename) {\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                String[] parts = parseCSVLine(line);\r\n                if (parts.length >= 6) {\r\n                    // Handle the case where middle name/nickname is quoted\r\n                    // Format: firstName,middleName/nickname,lastName,birthDate,gender,nationality\r\n                    String firstName = parts[0];\r\n                    String middleName = parts[1].replaceAll(\"\\\"\", \"\"); // Remove quotes\r\n                    String lastName = parts[2];\r\n                    LocalDate birthDate = LocalDate.parse(parts[3], DateTimeFormatter.ISO_LOCAL_DATE);\r\n                    char gender = parts[4].charAt(0);\r\n                    String nationality = parts[5];\r\n\r\n                    // Combine names appropriately\r\n                    String fullFirstName = middleName.isEmpty() ? firstName : firstName + \" \" + middleName;\r\n                    Actor actor = new Actor(fullFirstName, lastName, birthDate, gender, nationality);\r\n                    actor.setId(nextActorId++);\r\n                    actors.add(actor);\r\n                } else if (parts.length >= 5) {\r\n                    // Standard format: firstName,lastName,birthDate,gender,nationality\r\n                    LocalDate birthDate = LocalDate.parse(parts[2], DateTimeFormatter.ISO_LOCAL_DATE);\r\n                    Actor actor = new Actor(parts[0], parts[1], birthDate, parts[3].charAt(0), parts[4]);\r\n                    actor.setId(nextActorId++);\r\n                    actors.add(actor);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            throw new FileParsingException(\"Error loading actors: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public void loadDirectors(String filename) {\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                String[] parts = parseCSVLine(line);\r\n                if (parts.length >= 5) {\r\n                    // Handle the case where middle name/nickname is quoted\r\n                    // Format: firstName,middleName/nickname,lastName,birthDate,gender\r\n                    String firstName = parts[0];\r\n                    String middleName = parts[1].replaceAll(\"\\\"\", \"\"); // Remove quotes\r\n                    String lastName = parts[2];\r\n                    LocalDate birthDate = LocalDate.parse(parts[3], DateTimeFormatter.ISO_LOCAL_DATE);\r\n                    char gender = parts[4].charAt(0);\r\n\r\n                    // Combine names appropriately\r\n                    String fullFirstName = middleName.isEmpty() ? firstName : firstName + \" \" + middleName;\r\n                    Director director = new Director(fullFirstName, lastName, birthDate, gender);\r\n                    director.setId(nextDirectorId++);\r\n                    directors.add(director);\r\n                } else if (parts.length >= 4) {\r\n                    // Standard format: firstName,lastName,birthDate,gender\r\n                    LocalDate birthDate = LocalDate.parse(parts[2], DateTimeFormatter.ISO_LOCAL_DATE);\r\n                    Director director = new Director(parts[0], parts[1], birthDate, parts[3].charAt(0));\r\n                    director.setId(nextDirectorId++);\r\n                    directors.add(director);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            throw new FileParsingException(\"Error loading directors: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public void loadMovies(String filename) {\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                String[] parts = parseCSVLine(line);\r\n                if (parts.length >= 6) {\r\n                    String title = parts[0];\r\n                    int year = Integer.parseInt(parts[1]);\r\n                    Genre genre = Genre.valueOf(parts[2].toUpperCase().replace(\" \", \"_\"));\r\n                    int duration = Integer.parseInt(parts[3]);\r\n                    Director director = findDirectorByName(parts[4]);\r\n                    double imdbRating = Double.parseDouble(parts[5]);\r\n\r\n                    List<Actor> movieActors = new ArrayList<>();\r\n                    if (parts.length > 6) {\r\n                        String[] actorNames = parts[6].split(\";\");\r\n                        for (String actorName : actorNames) {\r\n                            Actor actor = findActorByName(actorName.trim());\r\n                            if (actor != null) {\r\n                                movieActors.add(actor);\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    // Handle case where director might be null\r\n                    Movie movie;\r\n                    if (director != null) {\r\n                        movie = new Movie(title, year, director, null, duration, movieActors);\r\n                    } else {\r\n                        // Create a movie with genre and director name from the file when director object is not found\r\n                        movie = new Movie(title, year, genre.name(), parts[4], new HashMap<>());\r\n                        movie.setActors(movieActors);\r\n                    }\r\n                    movie.setId(nextMovieId++);\r\n                    movie.setImdbRating(imdbRating);\r\n                    movies.add(movie);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            throw new FileParsingException(\"Error loading movies: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public void loadSeries(String filename) {\r\n        try (BufferedReader reader = new BufferedReader(new FileReader(\"src/main/resources/data/\" + filename))) {\r\n            String line;\r\n            while ((line = reader.readLine()) != null) {\r\n                String[] parts = parseCSVLine(line);\r\n                if (parts.length >= 2) {\r\n                    String title = parts[0];\r\n                    Genre genre = Genre.valueOf(parts[1].toUpperCase().replace(\" \", \"_\"));\r\n\r\n                    Series series = new Series(title);\r\n                    series.setGenre(genre);  // Set the genre from the file\r\n                    series.setId(nextSeriesId++);\r\n                    this.series.add(series);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            throw new FileParsingException(\"Error loading series: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n    public void addUser(User user) {\r\n        if (findUserByUsername(user.getUsername()) != null) {\r\n            throw new DuplicateUsernameException(\"Username already exists: \" + user.getUsername());\r\n        }\r\n        user.setId(nextUserId++);\r\n        users.add(user);\r\n    }\r\n\r\n    public void addActor(Actor actor) {\r\n        actor.setId(nextActorId++);\r\n        actors.add(actor);\r\n    }\r\n\r\n    public void addDirector(Director director) {\r\n        director.setId(nextDirectorId++);\r\n        directors.add(director);\r\n    }\r\n\r\n    public void addMovie(Movie movie) {\r\n        if (findMovieByTitle(movie.getTitle()) != null) {\r\n            throw new DuplicateContentException(\"Movie already exists: \" + movie.getTitle());\r\n        }\r\n        movie.setId(nextMovieId++);\r\n        movies.add(movie);\r\n    }\r\n\r\n    public void addSeries(Series series) {\r\n        if (findSeriesByTitle(series.getTitle()) != null) {\r\n            throw new DuplicateContentException(\"Series already exists: \" + series.getTitle());\r\n        }\r\n        series.setId(nextSeriesId++);\r\n        this.series.add(series);\r\n    }\r\n\r\n    public void removeMovie(Movie movie) {\r\n        if (movie == null) {\r\n            throw new IllegalArgumentException(\"Movie cannot be null\");\r\n        }\r\n        boolean removed = movies.remove(movie);\r\n        if (!removed) {\r\n            throw new IllegalArgumentException(\"Movie not found in collection: \" + movie.getTitle());\r\n        }\r\n    }\r\n\r\n    public void removeSeries(Series series) {\r\n        if (series == null) {\r\n            throw new IllegalArgumentException(\"Series cannot be null\");\r\n        }\r\n        boolean removed = this.series.remove(series);\r\n        if (!removed) {\r\n            throw new IllegalArgumentException(\"Series not found in collection: \" + series.getTitle());\r\n        }\r\n    }\r\n\r\n    public User findUserByUsername(String username) {\r\n        return users.stream()\r\n                .filter(user -> user.getUsername().equals(username))\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n    public Actor findActorByName(String name) {\r\n        return actors.stream()\r\n                .filter(actor -> actor.getFullName().equals(name))\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n    public Director findDirectorByName(String name) {\r\n        return directors.stream()\r\n                .filter(director -> director.getFullName().equals(name))\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n    public Movie findMovieByTitle(String title) {\r\n        return movies.stream()\r\n                .filter(movie -> movie.getTitle().equals(title))\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n    public Series findSeriesByTitle(String title) {\r\n        return series.stream()\r\n                .filter(series -> series.getTitle().equals(title))\r\n                .findFirst()\r\n                .orElse(null);\r\n    }\r\n\r\n    public List<Content> searchContent(SearchCriteria criteria) {\r\n        List<Content> result = new ArrayList<>();\r\n\r\n        // Search movies\r\n        result.addAll(movies.stream()\r\n                .filter(movie -> matchesCriteria(movie, criteria))\r\n                .toList());\r\n\r\n        // Search series\r\n        result.addAll(series.stream()\r\n                .filter(series -> matchesCriteria(series, criteria))\r\n                .toList());\r\n\r\n        // Apply sorting\r\n        sortContent(result, criteria);\r\n\r\n        return result;\r\n    }\r\n\r\n    private void sortContent(List<Content> content, SearchCriteria criteria) {\r\n        if (content.isEmpty()) return;\r\n\r\n        switch (criteria.getSortBy().toLowerCase()) {\r\n            case \"title\":\r\n                content.sort((a, b) -> criteria.isSortDescending()\r\n                        ? b.getTitle().compareToIgnoreCase(a.getTitle())\r\n                        : a.getTitle().compareToIgnoreCase(b.getTitle()));\r\n                break;\r\n            case \"year\":\r\n                content.sort((a, b) -> {\r\n                    int yearA = a.getYear().getYear() + 1900;\r\n                    int yearB = b.getYear().getYear() + 1900;\r\n                    return criteria.isSortDescending()\r\n                            ? Integer.compare(yearB, yearA)\r\n                            : Integer.compare(yearA, yearB);\r\n                });\r\n                break;\r\n            case \"rating\":\r\n                content.sort((a, b) -> {\r\n                    double ratingA = a instanceof Movie ? ((Movie) a).getImdbRating() : a.calculateAverageUserRating();\r\n                    double ratingB = b instanceof Movie ? ((Movie) b).getImdbRating() : b.calculateAverageUserRating();\r\n                    return criteria.isSortDescending()\r\n                            ? Double.compare(ratingB, ratingA)\r\n                            : Double.compare(ratingA, ratingB);\r\n                });\r\n                break;\r\n            case \"duration\":\r\n                content.sort((a, b) -> {\r\n                    int durationA = a instanceof Movie ? ((Movie) a).getDuration() : 0;\r\n                    int durationB = b instanceof Movie ? ((Movie) b).getDuration() : 0;\r\n                    return criteria.isSortDescending()\r\n                            ? Integer.compare(durationB, durationA)\r\n                            : Integer.compare(durationA, durationB);\r\n                });\r\n                break;\r\n            default:\r\n                // Default to title sorting\r\n                content.sort((a, b) -> a.getTitle().compareToIgnoreCase(b.getTitle()));\r\n        }\r\n    }\r\n\r\n    private void sortMovies(List<Movie> movies, SearchCriteria criteria) {\r\n        if (movies.isEmpty()) return;\r\n\r\n        switch (criteria.getSortBy().toLowerCase()) {\r\n            case \"title\":\r\n                movies.sort((a, b) -> criteria.isSortDescending()\r\n                        ? b.getTitle().compareToIgnoreCase(a.getTitle())\r\n                        : a.getTitle().compareToIgnoreCase(b.getTitle()));\r\n                break;\r\n            case \"year\":\r\n                movies.sort((a, b) -> {\r\n                    int yearA = a.getYear().getYear() + 1900;\r\n                    int yearB = b.getYear().getYear() + 1900;\r\n                    return criteria.isSortDescending()\r\n                            ? Integer.compare(yearB, yearA)\r\n                            : Integer.compare(yearA, yearB);\r\n                });\r\n                break;\r\n            case \"rating\":\r\n                movies.sort((a, b) -> {\r\n                    double ratingA = a.getImdbRating();\r\n                    double ratingB = b.getImdbRating();\r\n                    return criteria.isSortDescending()\r\n                            ? Double.compare(ratingB, ratingA)\r\n                            : Double.compare(ratingA, ratingB);\r\n                });\r\n                break;\r\n            case \"duration\":\r\n                movies.sort((a, b) -> {\r\n                    int durationA = a.getDuration();\r\n                    int durationB = b.getDuration();\r\n                    return criteria.isSortDescending()\r\n                            ? Integer.compare(durationB, durationA)\r\n                            : Integer.compare(durationA, durationB);\r\n                });\r\n                break;\r\n            default:\r\n                // Default to title sorting\r\n                movies.sort((a, b) -> a.getTitle().compareToIgnoreCase(b.getTitle()));\r\n        }\r\n    }\r\n\r\n    private boolean matchesCriteria(Content content, SearchCriteria criteria) {\r\n        // Title search\r\n        if (criteria.getTitle() != null && !content.getTitle().toLowerCase().contains(criteria.getTitle().toLowerCase())) {\r\n            return false;\r\n        }\r\n\r\n        // User rating range\r\n        double avgUserRating = content.calculateAverageUserRating();\r\n        if (avgUserRating < criteria.getMinUserRating() || avgUserRating > criteria.getMaxUserRating()) {\r\n            return false;\r\n        }\r\n\r\n        // Year range\r\n        if (criteria.hasYearFilter()) {\r\n            int contentYear = content.getYear().getYear() + 1900;\r\n            if (criteria.getMinYear() != null && contentYear < criteria.getMinYear()) {\r\n                return false;\r\n            }\r\n            if (criteria.getMaxYear() != null && contentYear > criteria.getMaxYear()) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // Genre filter\r\n        if (criteria.hasGenreFilter()) {\r\n            if (content instanceof Movie movie) {\r\n                boolean hasMatchingGenre = criteria.getGenres().stream()\r\n                        .anyMatch(genre -> movie.hasGenre(genre) || movie.getGenre().equals(genre));\r\n                if (!hasMatchingGenre) return false;\r\n            } else {\r\n                // For non-movie content, check primary genre\r\n                if (!criteria.getGenres().contains(content.getGenre())) {\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Movie-specific criteria\r\n        if (content instanceof Movie movie) {\r\n            // IMDB rating range\r\n            if (movie.getImdbRating() < criteria.getMinImdbRating() ||\r\n                    movie.getImdbRating() > criteria.getMaxImdbRating()) {\r\n                return false;\r\n            }\r\n\r\n            // Duration range\r\n            if (criteria.hasDurationFilter()) {\r\n                if (criteria.getMinDuration() != null && movie.getDuration() < criteria.getMinDuration()) {\r\n                    return false;\r\n                }\r\n                if (criteria.getMaxDuration() != null && movie.getDuration() > criteria.getMaxDuration()) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // Actor search\r\n            if (criteria.getActorName() != null) {\r\n                boolean hasActor = movie.getActors().stream()\r\n                        .anyMatch(actor -> actor.getFullName().toLowerCase().contains(criteria.getActorName().toLowerCase()));\r\n                if (!hasActor) return false;\r\n            }\r\n\r\n            // Director search\r\n            if (criteria.getDirectorName() != null) {\r\n                if (movie.getDirector() == null ||\r\n                        !movie.getDirector().toLowerCase().contains(criteria.getDirectorName().toLowerCase())) {\r\n                    return false;\r\n                }\r\n            }\r\n\r\n            // Description search\r\n            if (criteria.getDescription() != null) {\r\n                String description = movie.getDescription();\r\n                return description != null &&\r\n                        description.toLowerCase().contains(criteria.getDescription().toLowerCase());\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    // Getters\r\n    public List<User> getUsers() {\r\n        return new ArrayList<>(users);\r\n    }\r\n\r\n    public List<Actor> getActors() {\r\n        return new ArrayList<>(actors);\r\n    }\r\n\r\n    public List<Director> getDirectors() {\r\n        return new ArrayList<>(directors);\r\n    }\r\n\r\n    public List<Movie> getMovies() {\r\n        return new ArrayList<>(movies);\r\n    }\r\n\r\n    public List<Series> getSeries() {\r\n        return new ArrayList<>(series);\r\n    }\r\n\r\n    public int getNextSeasonId() {\r\n        return nextSeasonId;\r\n    }\r\n\r\n    public void setNextSeasonId(int nextSeasonId) {\r\n        this.nextSeasonId = nextSeasonId;\r\n    }\r\n\r\n    public int getNextEpisodeId() {\r\n        return nextEpisodeId;\r\n    }\r\n\r\n    public void setNextEpisodeId(int nextEpisodeId) {\r\n        this.nextEpisodeId = nextEpisodeId;\r\n    }\r\n\r\n    public List<Movie> searchMovies(SearchCriteria criteria) {\r\n        List<Movie> result = movies.stream()\r\n                .filter(movie -> matchesCriteria(movie, criteria))\r\n                .toList();\r\n\r\n        // Convert to ArrayList since toList() returns an unmodifiable list\r\n        List<Movie> modifiableResult = new ArrayList<>(result);\r\n\r\n        // Apply sorting if criteria has sorting parameters\r\n        if (criteria.getSortBy() != null && !criteria.getSortBy().isEmpty()) {\r\n            sortMovies(modifiableResult, criteria);\r\n        }\r\n\r\n        return modifiableResult;\r\n    }\r\n\r\n    public List<Movie> getAllMovies() {\r\n        return new ArrayList<>(movies);\r\n    }\r\n\r\n    public void setAllMovies(List<Movie> newMovies) {\r\n        if (newMovies != null) {\r\n            this.movies.clear();\r\n            this.movies.addAll(newMovies);\r\n        }\r\n    }\r\n\r\n    public void rateMovie(Movie selected, double rating) {\r\n        if (rating < 0.0 || rating > 10.0) {\r\n            throw new IllegalArgumentException(\"Rating must be between 0.0 and 10.0\");\r\n        }\r\n\r\n        // Find the movie in our collection\r\n        Movie movie = findMovieByTitle(selected.getTitle());\r\n        if (movie != null) {\r\n            // For simplicity, we'll use a fixed user ID (1) for now\r\n            // In a real application, this would be the current user's ID\r\n            int userId = 1;\r\n            movie.addUserRating(userId, (int) Math.round(rating));\r\n        }\r\n    }\r\n\r\n    public List<Series> getAllSeries() {\r\n        return new ArrayList<>(series);\r\n    }\r\n\r\n    public List<Actor> getAllActors() {\r\n        return new ArrayList<>(actors);\r\n    }\r\n\r\n    public void setAllSeries(List<Series> newSeries) {\r\n        if (newSeries != null) {\r\n            this.series.clear();\r\n            this.series.addAll(newSeries);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Parses a CSV line handling quoted fields properly\r\n     *\r\n     * @param line the CSV line to parse\r\n     * @return array of parsed fields\r\n     */\r\n    private String[] parseCSVLine(String line) {\r\n        List<String> fields = new ArrayList<>();\r\n        StringBuilder currentField = new StringBuilder();\r\n        boolean inQuotes = false;\r\n\r\n        for (int i = 0; i < line.length(); i++) {\r\n            char c = line.charAt(i);\r\n\r\n            if (c == '\"') {\r\n                inQuotes = !inQuotes;\r\n                currentField.append(c); // Keep the quotes for now, we'll remove them later\r\n            } else if (c == ',' && !inQuotes) {\r\n                fields.add(currentField.toString().trim());\r\n                currentField = new StringBuilder();\r\n            } else {\r\n                currentField.append(c);\r\n            }\r\n        }\r\n\r\n        // Add the last field\r\n        fields.add(currentField.toString().trim());\r\n\r\n        return fields.toArray(new String[0]);\r\n    }\r\n}\r\n"
                },
                "codebaseEnabled": true
            },
            "createdAt": 1754384245942,
            "isInternal": false,
            "rawContent": {
                "type": "doc",
                "content": [
                    {
                        "type": "paragraph",
                        "content": [
                            {
                                "type": "text",
                                "text": "Make improvements to the whole projects"
                            }
                        ]
                    }
                ]
            },
            "autoAppliedRules": []
        }
    ],
    "isAgent": true,
    "isCustomAgent": false,
    "isUnitTestsAgent": false,
    "isE2EAgent": false,
    "isQnaAgent": false,
    "isRepoInfoAgent": false,
    "autoApply": true
}
}