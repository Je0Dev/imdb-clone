{
    "checksum": "ee4252add80f62328ed93187edcc664e685a0a1b9db75297627982c22f8bb2b3",
    "data": {
    "id": "97803bdd-37a4-4481-bfeb-7b874026d8ba",
    "createdAt": 1755179371528,
    "updatedAt": 1755179371533,
    "title": "/fix criteria.getStartYear() > 0 && content.get...",
    "messages": [
        {
            "id": "1c4c1c42-821c-4066-92fe-b7a78aeb18c7",
            "role": "user",
            "content": [
                {
                    "type": "command",
                    "commandName": "fix"
                },
                {
                    "type": "codeSnippet",
                    "text": "criteria.getStartYear() > 0 && content.getReleaseYear() < criteria.getStartYear()",
                    "language": "java"
                },
                {
                    "type": "text",
                    "text": "Operator '>' cannot be applied to 'char[]', 'int'"
                }
            ],
            "context": {
                "currentFile": {
                    "path": "C:\\Users\\MA$\\IdeaProjects\\imdb_clone\\src\\main\\java\\com\\papel\\imdb_clone\\service\\ContentService.java",
                    "fsPath": "C:/Users/MA$/IdeaProjects/imdb_clone/src/main/java/com/papel/imdb_clone/service/ContentService.java",
                    "content": "package com.papel.imdb_clone.service;\n\nimport com.papel.imdb_clone.data.RefactoredDataManager;\nimport com.papel.imdb_clone.data.SearchCriteria;\nimport com.papel.imdb_clone.exceptions.ContentNotFoundException;\nimport com.papel.imdb_clone.exceptions.EntityNotFoundException;\nimport com.papel.imdb_clone.model.*;\nimport com.papel.imdb_clone.service.cache.SearchCacheService;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.locks.ReentrantReadWriteLock;\nimport java.util.stream.Collectors;\n\n/**\n * Unified service for managing all types of content (Movies, Series, etc.).\n * Provides high-level operations for content management including CRUD and search.\n */\npublic class ContentService<T extends Content> {\n    // Add missing fields\n    private final ReentrantReadWriteLock lock = new ReentrantReadWriteLock();\n    private final List<T> contentList = new CopyOnWriteArrayList<>();\n    private final AtomicInteger nextId = new AtomicInteger(1);\n    private static final Logger logger = LoggerFactory.getLogger(ContentService.class);\n    private static final Map<Class<?>, ContentService<?>> instances = new HashMap<>();\n\n    private final SearchCacheService searchCacheService;\n    private final Class<T> contentType;\n    private final Map<Integer, T> contentCache = new HashMap<>();\n\n    public ContentService(SearchCacheService searchCacheService, Class<T> contentType) {\n        this.searchCacheService = searchCacheService;\n        this.contentType = contentType;\n    }\n\n    /**\n     * Gets or creates a singleton instance of ContentService for the specified type.\n     *\n     * @param <T>         The content type\n     * @param dataManager The data manager (not used in current implementation)\n     * @return The ContentService instance\n     */\n    @SuppressWarnings(\"unchecked\")\n    public <T extends Content> ContentService<T> getInstance(RefactoredDataManager dataManager) {\n        return (ContentService<T>) instances.computeIfAbsent(contentType,\n                k -> new ContentService<>(SearchCacheService.getInstance(), contentType));\n    }\n\n    /**\n     * Alternative getInstance method for backward compatibility.\n     */\n    @SuppressWarnings(\"unchecked\")\n    public static <T extends Content> ContentService<T> getInstance(RefactoredDataManager dataManager, SearchCacheService searchCacheService) {\n        // For backward compatibility, return a generic Content service\n        return (ContentService<T>) instances.computeIfAbsent(Content.class,\n                k -> new ContentService<>(searchCacheService, Content.class));\n    }\n\n    // Add missing method\n    public void updateContent(T content) {\n        lock.writeLock().lock();\n        try {\n            int index = -1;\n            for (int i = 0; i < contentList.size(); i++) {\n                if (contentList.get(i).getId() == content.getId()) {\n                    index = i;\n                    break;\n                }\n            }\n            if (index != -1) {\n                contentList.set(index, content);\n                searchCacheService.invalidateCache();\n            } else {\n                throw new ContentNotFoundException(\"Content with id \" + content.getId() + \" not found\");\n            }\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    /**\n     * Finds content by its ID.\n     *\n     * @param id The content ID\n     * @return The content if found\n     * @throws ContentNotFoundException if content is not found\n     */\n    public T findById(int id) throws ContentNotFoundException {\n        // Check cache first\n        if (contentCache.containsKey(id)) {\n            return contentCache.get(id);\n        }\n\n        // Search in the content list\n        lock.readLock().lock();\n        try {\n            Optional<T> found = contentList.stream()\n                    .filter(content -> content.getId() == id)\n                    .findFirst();\n\n            if (found.isPresent()) {\n                T content = found.get();\n                contentCache.put(id, content);\n                return content;\n            }\n        } finally {\n            lock.readLock().unlock();\n        }\n\n        throw new ContentNotFoundException(\"Content with ID \" + id + \" not found\");\n    }\n\n\n    /**\n     * Finds content by title (partial match).\n     *\n     * @param title The title to search for\n     * @return List of content matching the title\n     */\n    public List<T> findByTitle(String title) {\n        if (title == null || title.trim().isEmpty()) {\n            return List.of();\n        }\n\n        String searchTerm = title.toLowerCase().trim();\n        lock.readLock().lock();\n        try {\n            return contentList.stream()\n                    .filter(content -> content.getTitle().toLowerCase().contains(searchTerm))\n                    .collect(Collectors.toList());\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n\n    /**\n     * Saves content (creates or updates).\n     *\n     * @param content The content to save\n     * @return The saved content (with ID if new)\n     */\n    public T save(T content) {\n        if (content == null) {\n            throw new IllegalArgumentException(\"Content cannot be null\");\n        }\n\n        lock.writeLock().lock();\n        try {\n            if (content.getId() == 0) {\n                // New content\n                content.setId(nextId.getAndIncrement());\n                contentList.add(content);\n                logger.info(\"Created new {}: {}\", contentType.getSimpleName(), content.getTitle());\n\n                // Invalidate search cache\n                searchCacheService.invalidateCache();\n            } else {\n                // Update existing\n                int index = -1;\n                for (int i = 0; i < contentList.size(); i++) {\n                    if (contentList.get(i).getId() == content.getId()) {\n                        index = i;\n                        break;\n                    }\n                }\n\n                if (index != -1) {\n                    contentList.set(index, content);\n                    logger.info(\"Updated {}: {}\", contentType.getSimpleName(), content.getTitle());\n\n                    // Invalidate search cache\n                    searchCacheService.invalidateCache();\n                } else {\n                    throw new EntityNotFoundException(contentType, content.getId());\n                }\n            }\n            return content;\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    /**\n     * Deletes content by ID.\n     *\n     * @param id The ID of the content to delete\n     * @return true if the content was found and deleted, false otherwise\n     */\n    public boolean delete(int id) {\n        lock.writeLock().lock();\n        try {\n            boolean removed = contentList.removeIf(content -> content.getId() == id);\n            if (removed) {\n                // Invalidate search cache\n                searchCacheService.invalidateCache();\n            }\n            return removed;\n        } finally {\n            lock.writeLock().unlock();\n        }\n    }\n\n    /**\n     * Gets all content of this service's type.\n     *\n     * @return List of all content\n     */\n    public List<T> getAll() {\n        lock.readLock().lock();\n        try {\n            return List.copyOf(contentList);\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n\n\n    /**\n     * Searches content based on the provided criteria.\n     *\n     * @param criteria The search criteria\n     * @return List of content matching the criteria\n     */\n    public List<T> search(SearchCriteria criteria) {\n        if (criteria == null) {\n            return List.of();\n        }\n\n        // Check cache first\n        String cacheKey = criteria + \"_\" + contentType.getSimpleName();\n\n        List<T> cachedResults = (List<T>) searchCacheService.getFromCache(cacheKey);\n\n        if (cachedResults != null) {\n            return cachedResults;\n        }\n\n        // Perform search if not in cache\n        lock.readLock().lock();\n        try {\n            List<T> results = contentList.stream()\n                    .filter(content -> {\n                        // Filter by title if provided\n                        if (criteria.getTitle() != null && !criteria.getTitle().isEmpty()) {\n                            if (!content.getTitle().toLowerCase().contains(criteria.getTitle().toLowerCase())) {\n                                return false;\n                            }\n                        }\n\n                        // Filter by year range if provided\n                        if (criteria.getStartYear() > 0 && content.getReleaseYear() < criteria.getStartYear()) {\n                            return false;\n                        }\n                        return criteria.getEndYear() <= 0 || content.getReleaseYear() <= criteria.getEndYear();\n                    })\n                    .collect(Collectors.toList());\n\n            // Cache the results\n            searchCacheService.addToCache(cacheKey, results);\n\n            return results;\n        } finally {\n            lock.readLock().unlock();\n        }\n    }\n\n    /**\n     * Saves a rating for content.\n     *\n     * @param rating The rating to save\n     */\n    public void saveRating(Rating rating) {\n        if (rating == null) {\n            throw new IllegalArgumentException(\"Rating cannot be null\");\n        }\n\n        try {\n            // Validate that the content exists\n            findById(rating.getContentId());\n\n            // For now, we'll just return the rating as-is\n            logger.info(\"Rating saved for content ID {}: {} stars\",\n                    rating.getContentId(), rating.getScore());\n\n        } catch (ContentNotFoundException e) {\n            throw new IllegalArgumentException(\"Cannot rate non-existent content with ID: \" + rating.getContentId(), e);\n        }\n    }\n\n    public void saveContent(Series breakingBad) {\n    }\n\n    public void saveContent(Movie movie) {\n    }\n\n    public void saveContent(Episode episode) {\n    }\n}\n",
                    "language": "java"
                },
                "codebaseEnabled": true
            },
            "createdAt": 1755179371533,
            "isInternal": false,
            "rawContent": {
                "type": "doc",
                "content": [
                    {
                        "type": "paragraph",
                        "content": [
                            {
                                "type": "command",
                                "attrs": {
                                    "label": "fix"
                                },
                                "content": [
                                    {
                                        "type": "text",
                                        "text": "fix: "
                                    }
                                ]
                            },
                            {
                                "type": "codeBlock",
                                "attrs": {
                                    "language": "java"
                                },
                                "content": [
                                    {
                                        "type": "text",
                                        "text": "criteria.getStartYear() > 0 && content.getReleaseYear() < criteria.getStartYear()"
                                    }
                                ]
                            },
                            {
                                "type": "text",
                                "text": "Operator '>' cannot be applied to 'char[]', 'int'"
                            }
                        ]
                    }
                ]
            },
            "autoAppliedRules": []
        }
    ],
    "isAgent": true,
    "isCustomAgent": false,
    "isUnitTestsAgent": false,
    "isE2EAgent": false,
    "isQnaAgent": false,
    "isRepoInfoAgent": false
}
}